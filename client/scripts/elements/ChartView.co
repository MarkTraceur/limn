define ['elements/Base'], (BaseElement) ->
    class ChartView extends BaseElement
        initialize: ->
            self = this
            self.metrics = ko.observableArray()
            self.metricLabels = ko.computed ->
                self.metrics().map (m) -> m.columnHeader()
            self.isChart = true
            
            self.xScale = ko.observable(d3.time.scale().clamp(true))
            self.yScale = ko.observable(d3.scale.log())
            self.xSteps = ko.observable([])
            
            # updates the scales when metrics change
            self.scales = ko.computed ->
                xDomain = d3.extent _.flatten self.metrics().map (m) -> m.dates()
                self.xScale().domain xDomain
                
                yDomain = d3.extent _.flatten self.metrics().map (m) -> m.column()
                self.yScale().domain yDomain.reverse()
                
                if self.metrics?().length > 0
                    self.xSteps self.metrics()[0].dates()
                    true
                else
                    false
            
            self.colorScale = d3.scale.category20()
            self.lineGenerator = d3.svg.line()
                .x (d, i) -> self.xScale() self.xSteps()[i] # TODO: assumes all metrics have the same x domain
                .y (d, i) -> self.yScale() d
                .interpolate 'linear'
        
        build: (parentElement) ->
            @sel = parentElement.append 'svg'
            @el = $(parentElement[0][0]).find 'svg'
            
            @xScale().range [0, @el.innerWidth()]
            @yScale().range [0, @el.innerHeight()]
            
            @renderChildren @sel
        
        height: -> @el.innerHeight()
        width: -> @el.innerWidth()
        
        
        /* HELPER FUNCTIONS */
        
        /**
         * @public
         * Formats a number as Thousands, Millions, Billions, etc.
         * @param {number} n
         * @returns {string} string representation of n
         */
        numberFormatter: (n) ->
            numberFormats = [
                { ge: 1000000000000,    f: 'T' },
                { ge: 1000000000,       f: 'B' },
                { ge: 1000000,          f: 'M' },
                { ge: 1000,             f: 'K' },
            ]
            for format of numberFormats
                if n >= format.ge
                    trimmed = n/format.ge
                    trimmed = trimmed.toFixed(1) unless trimmed == Math.round(trimmed)
                    return trimmed + format.f
            return n

        /**
         * @public
         * Default standard date formatter
         * @param {Date}
         * returns {string} the date formatted as [abrev. month] [YYYY]
         */
        dateFormatter: d3.time.format("%b %Y")
