# TODO: global bad, make this part of a real singleton Storage mechanism
datasources = {}

define ->
    class Storage
        load: (path, callback) ->
            ret = {}
            options = do
                url: path,
                async: !!callback
                error: (err) -> ret.error = err
            
            if callback
                options.success = callback
            else
                options.success = (data) -> ret.loaded = data
            
            $.ajax options
            ret.loaded
        
        # TODO: make this not crappy and synchronous
        getTimeseriesMetric: (sourceId, callback) ->
            self = this
            if sourceId in datasources
                datasources[sourceId]
            else
                $.ajax do
                    url: "/datafiles/#{sourceId}.csv",
                    async: false
                    success: (csv) ->
                        rows = d3.csv.parseRows csv
                        dataRows = rows.slice(1, rows.length)
                        
                        datasources[sourceId] = do
                            columnHeaders: rows[0],
                            dates: new Array(),
                            columns: dataRows[0].map -> new Array()
                        
                        dataRows.map (row) ->
                            datasources[sourceId].dates.push row[0]
                            row.map (item, col) ->
                                datasources[sourceId].columns[col].push item
                
                datasources[sourceId]
    
    new Storage()
