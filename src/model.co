{ _, op, root, generateId, guidFor,
} = require './util'
{ EventEmitter, ReadyEmitter,
} = require 'emitters'
{ Resource,
} = require './resource'

ko = require 'knockout'

unwrap = ko.utils.unwrapObservable




/**
 * @class Root-class for all Models.
 * @extends EventEmitter
 * @mixes Resource
 */
class exports.Model extends EventEmitter
    # Apply Resource mixin
    Resource.mix this
    
    /**
     * Unique identifier for this object. Uniqueness is only guaranteed for this
     * pageload session; this value is safe to use in circumstances requiring numeric identity
     * (such as calculating a hashkey for a Map, or for DOM id attributes) but not when
     * global uniqueness is required.
     * @type String
     */
    __id__ : null
    
    /**
     * Attribute key used to uniquely identify this model instance. Note that
     * it should be expected that models sometimes have a null id prior to save,
     * as the server may be used to enforce uniqueness.
     * @type String
     */
    idAttribute : 'id'
    
    /**
     * Attribute data of the model. Individual properties are also aliased 
     * onto the model object itself if no property already exists.
     * @type Map<Key, ko.observable>
     */
    attributes : null
    
    /**
     * Maps attribute keys to sub-models.
     * @type Map<Key, ModelClass>
     */
    attributeTypes : null
    
    
    
    /**
     * @constructor
     */
    (attributes={}) ->
        @__id__     = generateId()
        attributes  = _.merge @defaults(), attributes
        @attributes = ko.mapping.fromJS attributes, @generateMapping(), {}
        _.defaults this, @attributes
        this
    
    
    /**
     * Invoked to acquire default attribute values.
     * TODO COMMENT
     * @returns {Object} Default attribute values.
     */
    defaults: ->
        { id:null }
    
    /**
     * Gets the value of the id attribute for this model.
     * @returns {String} Instance's id.
     */
    getId: ->
        @get(@idAttribute or 'id') or null
    
    /**
     * @returns {Boolean} Whether the model has been saved to the server.
     */
    isNew: ->
        @getId()?
    
    /**
     * Clone this model.
     * 
     * @returns {Model} A new instance of this model, bearing the same attributes.
     */
    clone: ->
        ModelClass = @constructor
        new ModelClass ko.mapping.toJS @attributes
    
    
    /* * * *  Knockout-Aware Accessors  * * * {{{ */
    
    /**
     * Gets the attribute value at `key`.
     * @returns {*} Value at `key`.
     */
    get: (key) ->
        if ko.isObservable val = @attributes[key]
            val()
        else
            val
    
    /**
     * Puts a single attribute value to `key`.
     * 
     * @protected
     * @param {String} key The key to set.
     * @param {*} val Value to set at `key`.
     * @returns {this}
     */
    _set: (key, val) ->
        return this unless key? and val is not void
        
        obs = @attributes[key]
        unless ko.isObservable obs
            throw new Error("Key '#key' is not observable!")
        obs val
        this
    
    /**
     * Sets attribute values, taking either a single (key, value)-pair, or a map of them.
     * 
     * @param {String|Object} key The key to set. If an object is supplied here, each key will be set with its value on the target object.
     * @param {*} [value] Value to set at `key`. Omit this if an object of KV-pairs was passed as `key`.
     * @returns {this}
     */
    set: (key, val) ->
        return this unless key?
        if key and _.isObject(key)
            values = key
        else
            values = { "#key": value }
        for key, value in values
            @_set key, value
        this
    
    /**
     * Sets the attribute value at `key` to `null`.
     * @returns {this}
     */
    unset: (key) ->
        obs = @attributes[key]
        unless ko.isObservable obs
            throw new Error("Key '#key' is not observable!")
        obs null
        this
    
    # }}}
    
    
    
    /**
     * Transforms the `attributeType` mapping object (keyname -> Model class) into a `ko.mapping`
     * options object.
     * @returns {Object} Knockout mapping object for all listed (key, type) pairs.
     */
    generateMapping: ->
        return {} unless @attributeTypes
        _.reduce do
            @attributeTypes
            (mappers, ModelType, key) ->
                id = ModelType::idAttribute or 'id'
                mappers[key] =
                    key: (data) ->
                        # TODO: allow customization of id/key
                        unwrap data[id]
                    
                    create: (opts) ->
                        {data, parent} = opts
                        new ModelType data
                    
                    update: (opts) ->
                        {data, parent, observable} = opts
                        if observable
                            ko.mapping.fromJS data, {}, unwrap(observable)
                        else
                            new ModelType data
                mappers
            {}
    
    
    toJSON: ->
        json = ko.mapping.toJS @attributes
        for k, v in json
            delete json[k] unless v?
        json
    
    toString: ->
        "#{@..displayName or @..name}(cid=#{@cid}, id=#{@id})"
    
    
    
    /* * * *  Class Methods  * * * {{{ */
    
    # Make the Model class-object itself an event emitter, so it can fire global events
    this import EventEmitter::
    
    
    /**
     * When Model is extended, copy over all class methods to the Subclass (including this).
     */
    @extended = (Subclass) ->
        for k, v in this
            Subclass[k] = v if typeof v is 'function' and not _.contains <[ apply call constructor toString ]>, k
        Subclass.__super__ = this::
        Subclass
    
    # }}}

