ko = require 'knockout'

/**
 * An array of ko.observable items.  Keeps a mirror metadata array to track subscriptions to these items
 */
ko.observablesArray = (initialValues) ->
    if arguments.length == 0
        # Zero-parameter constructor initializes to empty array
        initialValues = []
    
    if initialValues? and not ('length' in initialValues)
        throw new Error "The argument passed when initializing an observable array must be an array, or null, or undefined."
    
    # create the observable and populate with private and public methods
    result = ko.observable()
    result.actions = {}
    result.actions import { 'created', 'add', 'remove', 'change', 'replace' }
    result.shouldEnforce = true
    ko.utils.extend(result, privateMethods)
    ko.utils.extend(result, ko.observablesArray['fn'])
    result._reportAction result.actions.created, initialValues
    result
    
    # keep the same structure if the observable is written to
    result.subscribe ->
        # XXX: this fires on any change (push, remove, etc. as well as re-initializing the array)
        # so I use this shouldEnforce hack to prevent it from firing too much
        #   result.shouldEnforce is a flag that starts as true and gets reset to true by this subscription
        #   Every time our methods mutate the value, they change shouldEnforce to false indicating they know what they're doing
        if result.shouldEnforce
            enforceStructure.call result
        result.shouldEnforce = true
    
    result initialValues
    result

enforceStructure = (result) ->
    underlyingArray = @peek()
    for value, index of underlyingArray
        unless ko.isObservable value
            value = ko.observable value
        underlyingArray[index] = value
    
    @_refreshMetadata()

privateMethods =
    /**
     * Add a mirror array to track subscriptions to each of the observables in the first array
     * @param {number} index
     * @param {ko.observable} value
     */
    '_addMetadata': (index, value) ->
        @subscriptions[index] = value.subscribe ~>
            @_reportAction @actions.change, value
    
    /**
     * Disposes the subscription and removes the corresponding metadata array entry
     * @param {number} index
     */
    '_removeMetadata': (index) ->
        @subscriptions[index].dispose()
        @subscriptions.splice index, 1
    
    /**
     * Changes the mirror array in place
     * @param {number} index
     * @param {ko.observable} value
     */
    '_changeMetadata': (index, value) ->
        @subscriptions[index].dispose()
        @subscriptions[index] = value.subscribe ~>
            @_reportAction @actions.change, value
    
    /**
     * Disposes all the old subscriptions and creates new ones for every item in the underlying array
     */
    '_refreshMetadata': ->
        @subscriptions ?= []
        for s of @subscriptions
            s.dispose()
        @subscriptions ?= new Array(underlyingArray.length)
        
        underlyingArray = @peek()
        for value, index of underlyingArray
            @_addMetadata index, value
        
        return
    
    /**
     * Changes the observable `this.lastAction` and the array `this.lastChange` so subscribers can know what's going on with the array
     * @param {string} description a string representation of the action, can be:
     *      created     : the array was created
     *      add         : a value is pushed or added to the array in any way
     *      remove      : a value is popped or removed from the array in any way
     *      change      : a value in the array has changed
     * @param {Array} valueRepresentingChange if a single value is passed, it will be wrapped in an array
     */
    '_reportAction': (description, valueRepresentingChange) ->
        valueRepresentingChange ?= []
        unless valueRepresentingChange?.length
            valueRepresentingChange = [valueRepresentingChange]
        @lastAction ?= ko.observable()
        
        @lastChange = valueRepresentingChange
        @lastAction description


ko.observablesArray['fn'] =
    'push': (value) ->
        underlyingArray = @peek()
        unless ko.isObservable value
            value = ko.observable value
        
        @valueWillMutate()
        @_reportAction @actions.add, value
        newLength = underlyingArray.push value
        @_addMetadata newLength - 1, value
        @shouldEnforce = false
        @valueHasMutated()
        newLength
    
    'pop': ->
        underlyingArray = @peek()
        @valueWillMutate()
        @_removeMetadata underlyingArray.length - 1
        value = underlyingArray.pop()
        @_reportAction @actions.remove, value
        @shouldEnforce = false
        @valueHasMutated()
        value
    
    'remove': (valueOrPredicate) ->
        underlyingArray = @peek()
        removedValues = []
        if typeof valueOrPredicate == "function"
            predicate = valueOrPredicate
        else
            predicate = (value) -> value() is valueOrPredicate
        
        i = 0
        while i < underlyingArray.length
            value = underlyingArray[i]
            if predicate(value)
                if removedValues.length is 0
                    @valueWillMutate()
                
                removedValues.push value
                underlyingArray.splice i, 1
                @_removeMetadata i
                i--
            i++
        
        if removedValues.length
            @_reportAction @actions.remove, removedValues
            @shouldEnforce = false
            @valueHasMutated()
        
        removedValues
    
    'removeAll': (arrayOfValues) ->
        # If you passed zero args, we remove everything
        if arrayOfValues is undefined
            underlyingArray = @peek()
            allValues = underlyingArray.slice 0
            @valueWillMutate()
            underlyingArray.splice 0, underlyingArray.length
            @_reportAction @actions.remove, allValues
            @shouldEnforce = false
            @valueHasMutated()
            return allValues
        
        # If you passed an arg, we interpret it as an array of entries to remove
        unless arrayOfValues
            return []
        return @['remove']((value) ->
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0
        )
    
    'indexOf': (item) ->
        find = ko.utils.unwrapObservable item
        underlyingArray = @peek().map (v) -> ko.utils.unwrapObservable v
        ko.utils.arrayIndexOf underlyingArray, find
    
    'replace': (oldItem, newItem) ->
        index = @['indexOf'](oldItem)
        if index >= 0
            unless ko.isObservable newItem
                newItem = ko.observable newItem
            @valueWillMutate()
            @peek()[index] = newItem
            @_changeMetadata index, newItem
            @_reportAction @actions.replace, newItem
            @shouldEnforce = false
            @valueHasMutated()
    
/* TODO: destroy methods don't work ... look into why / how they are used
    'destroy': (valueOrPredicate) ->
        underlyingArray = @peek()
        if typeof valueOrPredicate == "function"
            predicate = valueOrPredicate
        else
            predicate = (value) -> value() is valueOrPredicate
        
        @valueWillMutate()
        for i from underlyingArray.length - 1 to 0 by -1
            value = underlyingArray[i]
            if predicate(value)
                underlyingArray[i]["_destroy"] = true
                @_removeMetadata i
        
        @shouldEnforce = false
        @valueHasMutated()
    
    'destroyAll': (arrayOfValues) ->
        # If you passed zero args, we destroy everything
        if arrayOfValues is undefined
            return @['destroy'](-> true)

        # If you passed an arg, we interpret it as an array of entries to destroy
        unless arrayOfValues
            return []
        return @['destroy']((value) ->
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0
        )
*/


/*
# Populate ko.observablesArray.fn with read/write functions from native arrays
# Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
# because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
ko.utils.arrayForEach ["reverse", "shift", "sort", "splice", "unshift"], (methodName) ->
    ko.observablesArray['fn'][methodName] = ->
        # Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
        # (for consistency with mutating regular observables)
        underlyingArray = @peek()
        @valueWillMutate()
        methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments)
        @shouldEnforce = false
        @valueHasMutated()
        methodCallResult


# Populate ko.observablesArray.fn with read-only functions from native arrays
ko.utils.arrayForEach ["slice"], (methodName) ->
    ko.observablesArray['fn'][methodName] = ->
        underlyingArray = @peek()
        underlyingArray[methodName].apply(underlyingArray, arguments)
*/

ko.exportSymbol('observablesArray', ko.observablesArray)
