_  = require 'underscore'
ko = require 'knockout'
require './add-extender'


/**
 * Coerce input to this observable to the supplied Model. If a `ko.observableArray`,
 * coercion will apply to the contents, wrapping .
 * 
 * @param {ko.observable} obs Property to decorate.
 * @param {Class<Model>} ModelType Model type to ensure.
 * @returns {ko.dependentObservable} Wrapped observable.
 */
exports.typedExtender = ko.addExtender 'typed', (obs, ModelType) ->
    coerce = (value) ->
        # XXX: accept arbitrary transform function instead of assuming Model constructor?
        return value if value instanceof ModelType
        # Do not wrap undefined or nulls
        return value unless value?
        new ModelType value
    
    # current = obs() # peek?
    current = obs.peek()
    
    # Wrap observer with the coercion transform
    wrapper = ko.computed do
        read  : obs
        write : (value) ->
            if _.isArray value
                # don't map, or we lose object identity with the backing array
                _.each value, (val, i) ->
                    value[i] = coerce val
            else
                value = coerce value
            obs value
    
    if _.isArray current
        # Wrap additive `ko.observableArray` methods to transform new data
        _.each <[ push unshift splice replace ]>, (methodName) ->
            origMethod = obs[methodName]
            switch methodName
            case 'splice'
                obs.splice = (start, drop, ...args) ->
                    origMethod.apply this, [start, drop].concat _.map(args, coerce)
            case 'replace'
                obs.replace = (oldItem, newItem) ->
                    origMethod.call this, oldItem, coerce(newItem)
            default
                obs[methodName] = (arg) ->
                    origMethod.apply this, _.map(arguments, coerce)
    
    # Copy over observable and observableArray methods
    _.defaults wrapper, obs
    
    # Update with starting value
    wrapper current
    
    # Replace with decorated property
    wrapper


/**
 * Convenience for wrapping a value in both an observable and the type coercion wrapper.
 * @returns {ko.dependentObservable}
 */
exports.typedObservable = ko.typedObservable = (ModelType, val) ->
    if _.isArray val
        obs = ko.observableArray val
    else
        obs = ko.observable val
    obs.typed ModelType


