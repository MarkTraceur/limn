_  = require 'underscore'
ko = require 'knockout'

/**
 * Coerce input to this observable to the supplied Model. If a `ko.observableArray`,
 * coercion will apply to the contents, wrapping .
 * 
 * @param {ko.observable} obs Property to decorate.
 * @param {Class<Model>} ModelType Model type to ensure.
 * @returns {ko.dependentObservable} Wrapped observable.
 */
exports.typedExtender = ko.addExtender 'typed', (obs, ModelType) ->
    coerce = (value) ->
        return value if value instanceof ModelType
        new ModelType value
    
    current = obs() # peek?
    
    # Wrap observer with the coercion transform
    wrapper = ko.computed do
        read  : obs
        write : (value) ->
            if _.isArray value
                newValue = _.map value, coerce
            else
                newValue = coerce value
            obs newValue
    
    if _.isArray current
        # Copy over observableArray methods that don't have ko.dependentObservable overrides
        _.defaults wrapper, ko.observableArray.fn
        
        # Wrap additive `ko.observableArray` methods to transform new data
        _.each <[ push unshift splice replace ]>, (methodName) ->
            origMethod = obs[methodName]
            switch methodName
            case 'splice'
                obs.splice = (start, drop, ...args) ->
                    origMethod.apply this, [start, drop].concat _.map(args, coerce)
            case 'replace'
                obs.replace = (oldItem, newItem) ->
                    origMethod.call this, oldItem, coerce(newItem)
            default
                obs[methodName] = (arg) ->
                    origMethod.apply this, _.map(arguments, coerce)
        
    
    # Update with starting value
    wrapper current
    
    # Replace with decorated property
    wrapper


/**
 * Convenience for wrapping a value in both an observable and the type coercion wrapper.
 * @returns {ko.dependentObservable}
 */
exports.typedObservable = ko.typedObservable = (ModelType, val) ->
    if _.isArray val
        obs = ko.observableArray val
    else
        obs = ko.observable val
    obs.typed ModelType


