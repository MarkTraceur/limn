_      = require 'underscore'
op     = require 'operator'


# Signal Constants
STOP_ITERATION = exports.STOP_ITERATION = {}
CONTINUE       = exports.CONTINUE = {}
HAS_NEXT       = exports.HAS_NEXT = {}


/**
 * @abstract
 * @class A stream Iterator, implementing the typical iteration interface (`hasNext`, `next`).
 */
class exports.Iterator
    
    /**
     * Number of values returned.
     * @type Number
     */
    count : 0
    
    
    /**
     * @constructor
     */
    ->
        @count = 0
    
    
    /**
     * Called to advance the iterator and fetch the next value.
     * @abstract
     * @protected
     * @returns {*}
     */
    getNext : -> ...
    
    
    /**
     * Called to check whether the iterator is exhausted. Calls should not
     * mutate the iterator's state.
     * 
     * @abstract
     * @returns {Boolean}
     */
    hasNext : -> ...
    
    
    /**
     * @abstract
     * @returns {Iterator} A copy of this iterator, with independent state.
     */
    clone: -> ...
    
    
    /**
     * Advance the iterator and return either `STOP_ITERATION`
     * or the next value.
     * 
     * @returns {*|STOP_ITERATION}
     */
    next: ->
        return STOP_ITERATION unless @hasNext()
        @count++
        @getNext()
    
    
    /**
     * Wrap this iterator in a `PipeIterator`, filtering and/or transforming each value with
     * the given `map` function before it is returned.
     * 
     * @param {Options} [options] Options:
     * @param {Function} [options.map] Function invoked to transform values.
     * @param {Function} [options.filter] Function invoked to filter values.
     * @returns {PipeIterator} Wrap this iterator in a `PipeIterator`,
     *  transforming each value before it is returned.
     */
    /**
     * Wrap this iterator in a `PipeIterator`, filtering and/or transforming each value with
     * the given `map` function before it is returned.
     * 
     * @param {Function} [map] Function invoked to transform values.
     * @param {Function} [filter] Function invoked to filter values.
     * @returns {PipeIterator} Wrap this iterator in a `PipeIterator`,
     *  transforming each value before it is returned.
     */
    pipe : (options) ->
        if typeof options is 'function'
            [ map, filter ] = arguments
            options = { map, filter }
        new PipeIterator this, options
    
    
    /**
     * Exhausts the Iterator from its current position, returning an array of its values.
     * @returns {Array} The values.
     */
    toArray : ->
        out = []
        while @hasNext()
            val = @next()
            break if val is STOP_ITERATION
            out.push val
        out


/**
 * @class Iterator which sequentially walks an Indexable -- an object with numeric
 * properties and a `length` attribute -- including Arrays, but also Array-likes 
 * such as the Arguments object, or HTML NodeLists.
 * @extends Iterator
 */
class exports.IndexIterator extends Iterator
    (@data, @start=0, @end=null, @step=1) ->
        @index = @start
        super ...
    
    /**
     * Advances the iterator's index.
     * @returns {Number} Current index.
     */
    nextIndex : -> @index += @step
    
    getNext   : -> @data[ @nextIndex() ]
    hasNext   : -> @index < (@end ? @data.length - 1)
    
    /**
     * @returns {Number} Iterator's length normalized to index iteration.
     */
    size : ->
        Math.floor( ((@end ? @data.length - 1) - @start) / @step )
    
    clone : ->
        IteratorClass = @constructor
        it = new IteratorClass @data, @start, @end, @step
        it.index = @index
        it.count = @count
        it


/**
 * @class IndexIterator that takes an array of many columns and zips
 * together the same index from each column to produce each value.
 * @extends IndexIterator
 */
class exports.ZipIterator extends IndexIterator
    
    (data) ->
        end = _.max _.pluck @data, 'length'
        super data, 0, end, 1
    
    getNext : -> _.pluck @data, @nextIndex()


/**
 * @class Iterator which wraps another, transforming each value with
 * the given `map` function before it is returned.
 * @extends Iterator
 */
class exports.PipeIterator extends Iterator
    
    (@iter, opts={}) ->
        {map, filter} = opts
        @map    = map       if typeof map    is 'function'
        @filter = filter    if typeof filter is 'function'
        super ...
    
    /**
     * Override to transform values before they are returned; this function
     * will be passed both `STOP_ITERATION` responses and normal values as
     * they occur. It may return whatever it pleases.
     * 
     * @param {*|STOP_ITERATION|HAS_NEXT} val Either the value provided by 
     *  `getNext()` or a signal; `HAS_NEXT` will be sent to allow the mapper
     *  to overrule the `hasNext()` call of the backing iterator.
     * @returns {*|STOP_ITERATION} Transformed value, including
     *  `STOP_ITERATION` when appropriate.
     */
    map: (val) ->
        return false if val is HAS_NEXT
        val
    
    /**
     * Invoked prior to transform to test whether a value should be
     * transformed and then included in the output stream.
     * 
     * @param {*|STOP_ITERATION} val Value provided by `getNext()`.
     * @returns {Boolean} Whether to include the value in the stream.
     */
    filter: (val) ->
        true
    
    getNext: ->
        val = STOP_ITERATION
        # Loop until we either find in acceptable value, or run out.
        while @iter.hasNext()
            val = @iter.getNext()
            break if val is STOP_ITERATION or @filter val
            val = STOP_ITERATION
        val = @map val if val is not STOP_ITERATION
        val
    
    hasNext: ->
        @iter.hasNext()
    
    clone: ->
        IteratorClass = @constructor
        it = new IteratorClass @iter, {@map, @filter}
        it.count = @count
        it
    


/**
 * @class Iterator which wraps another, offering values from the backing
 * stream until an aggregated value is produced. This allows streams to be
 * transformed into non-isometric forms.
 * @extends Iterator
 */
class exports.AggregationIterator extends Iterator
    
    (@iter, opts={}) ->
        {offer} = opts
        @offer = offer if typeof offer is 'function'
        super ...
    
    /**
     * Override to consider each value for aggregation, returning an aggregated
     * value or a signal to stop (`STOP_ITERATION`) or continue (`CONTINUE`).
     * 
     * `HAS_NEXT` will be sent so the function may control the injection of
     * synthetic elements into the stream even once the backing iterator is
     * exhausted.
     * 
     * @abstract
     * @param {*|STOP_ITERATION|HAS_NEXT} val
     * @returns {*|STOP_ITERATION|CONTINUE} An aggregated value, or a signal.
     */
    offer: (val) ->
        switch val
        case HAS_NEXT       then false
        default             then val
    
    getNext: ->
        # Loop until an aggregated value is ready or we run out.
        val = STOP_ITERATION
        while @hasNext()
            val = @offer @iter.next()
            break unless val is CONTINUE
        val
    
    hasNext: ->
        @iter.hasNext() or @offer(HAS_NEXT)
    
    clone: ->
        IteratorClass = @constructor
        it = new IteratorClass @iter, {@offer}
        it.count = @count
        it
    




