_    = require 'underscore'
_arr = require './array'


objToString = {}.toString
TYPENAME_PAT = /^\[object ([^\]]+)\]$/

STR_TO_TYPENAME = _arr.synthesize do
    <[ Boolean Number String Array Date RegExp Object Function ]>
    (name) -> [ "[object #name]", name ]

TRICKY_TYPES = { +Object, +Function }


_cls =
    
    /**
     * @returns {Boolean} Whether the given function is a class constructor.
     */
    isClass: (fn) ->
        return true if fn is Object
        typeof fn is 'function'     and
        _.isObject( proto = fn:: )  and do
            fn.__class__ is fn   or
            not _.isEmpty(proto) or
            not _.isPlainObject(proto)
    
    
    /**
     * @returns {String} The name of the type of the thing you passed me.
     */
    typeName : (o) ->
        # null, undefined
        return String(o) unless o?
        
        # Primitives &co are easy ...Except the tricky ones.
        return name unless TRICKY_TYPES[ name = objToString.call(o) ]
        
        # If it's a limn type, it'll help us out.
        return o.displayName or o.name or 'Class' if _.isClass o
        
        # Functions are complicated.
        if _.isFunction o
            
        
        return o.constructor
    
    
    /**
     * Creates a new instance of the given class without running its constructor.
     * 
     * @param {Class} Cls Class to instantiate.
     * @returns {Cls} New instance of the given class, created without running its constructor.
     */
    fabricate: (Cls) ->
        AnonymousInnerClass = ->
        AnonymousInnerClass:: = Cls::
        instance = new AnonymousInnerClass()
        instance.constructor = Cls
        instance
    
    
    /**
     * Creates a new instance of the given class, applying the given arguments Array to the constructor.
     * 
     * @param {Class} Cls Class to instantiate.
     * @param {Array} [args=[]] Arguments to pass to the class constructor.
     * @returns {Cls} New instance of the given class.
     */
    instantiate: (Cls, args=[]) ->
        instance = _cls.fabricate Cls
        Cls.apply instance, args
        instance
    
    
    /**
     * @returns {Array<Class>} The list of all superclasses for this class
     *  or object. Typically does not include Object or Function due to
     *  the prototype's constructor being set by the subclass.
     */
    getSuperClasses : function getSuperClasses(Cls)
        return [] unless Cls
        
        if Cls.__superclass__ or Cls.superclass or Cls.__super__?.constructor
            superclass = that unless that is Cls
        unless superclass
            Cls = Cls.constructor if typeof Cls is not 'function'
            if Cls.__superclass__ or Cls.superclass or Cls.__super__?.constructor
                superclass = that unless that is Cls
        unless superclass then []
        else [superclass].concat getSuperClasses superclass
    
    
    /**
     * Looks up an attribute on the prototype of each class in the class
     * hierarchy. Values from Object or Function are not typically included --
     * see the note at `getSuperClasses()`.
     * 
     * @param {Object} obj Object on which to reflect.
     * @param {String} prop Property to nab.
     * @returns {Array} List of the values, from closest parent to furthest.
     */
    pluckSuper : (obj, prop) ->
        return [] unless obj
        _ _cls.getSuperClasses(obj) .chain()
            .pluck 'prototype'
            .pluck prop 
            .value()
    
    
    /**
     * As `.pluckSuper()` but includes value of `prop` on passed `obj`. Values
     *  from Object or Function are not typically included -- see the note
     *  at `getSuperClasses()`.
     * 
     * @returns {Array} List of the values, starting with the object's own
     *  value, and then moving from closest parent to furthest.
     */
    pluckSuperAndSelf : (obj, prop) ->
        return [] unless obj
        [ obj[prop] ].concat _cls.pluckSuper(obj, prop)
    


exports import _cls
