/**
 * @fileOverview RESTful Resource Mixin. Mostly adapted from Backbone.
 * 
 * TODO: In-flight request tracking; squelch double-requests; ModelCache.
 */

{ _, op, root, generateId, guidFor, Mixin,
} = require './util'
{ EventEmitter,
} = require 'emitters'


### Helpers & Constants

urlError = -> throw new Error "A 'url' property or function must be specified!"

ACTION_TO_METHOD =
    create : 'POST'
    update : 'PUT'
    delete : 'DELETE'
    read   : 'GET'

DEFAULT_OPTIONS =
    /**
     * Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
     * will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
     * set a `X-Http-Method-Override` header.
     * @name emulateHTTP
     * @type Boolean
     */
    emulateHTTP : false
    
    /**
     * Turn on `emulateJSON` to support legacy servers that can't deal with direct
     * `application/json` requests ... will encode the body as
     * `application/x-www-form-urlencoded` instead and will send the model in a
     * form param named `model`.
     * @name emulateJSON
     * @type Boolean
     */
    emulateJSON : false



/**
 * @class Mixin which represents a remote resource following the REST pattern:
 * 
 * POST    /<RESOURCE>              ->  create
 * GET     /<RESOURCE>/:id          ->  show
 * PUT     /<RESOURCE>/:id          ->  update
 * DELETE  /<RESOURCE>/:id          ->  destroy
 * 
 */
class exports.Resource extends Mixin
    
    /* * * *  Instance Methods  * * * {{{ */
    
    /**
     * Root prepended to all resource requests
     * @type String
     */
    urlRoot : ''
    
    /**
     * The name of the resource -- by convention, resources are named with plural nouns.
     * @type String
     */
    resource : ''
    
    
    url: ->
        throw new Error "No Resource name found! (@resource=#{@resource}, model=#this)" unless @resource
        root = _.result this, 'urlRoot'
        id = encodeURIComponent(@getId() or '')
        _.compact [ root, @resource, id ]
            .map -> _.rtrim it, '/'
            .join '/'
    
    /**
     * Fetch the model from the server.
     * 
     * Fires a "before-fetch" event prior to execution, and a "fetch" event upon completion.
     * 
     * @param {Function} [successFn] Called on fetch success: successFn(model, response, status, xhr)
     * @param {Object} [options={}] Options passed to `sync()`.
     * @returns {XMLHTTPRequest}
     */
    fetch: (successFn, options={}) ->
        unless typeof successFn is 'function'
            [options, successFn] = [successFn, null]
        options.success = [successFn, options.success]
        @sync 'read', 'fetch', options
    
    /**
     * Save the model to the server.
     * 
     * Fires a "before-save" event prior to execution, and a "save" event upon completion.
     * 
     * @param {Function} [successFn] Called on save success: `successFn(model, response, status, xhr)`
     * @param {Object} [options={}] Options passed to `sync()`.
     * @returns {XMLHTTPRequest}
     */
    save: (successFn, options={}) ->
        unless typeof successFn is 'function'
            [options, successFn] = [successFn, null]
        action = if @isNew() then 'create' else 'update'
        options.success = [successFn, options.success]
        @sync action, 'save', options
    
    /**
     * Destroy the model.
     * 
     * Fires a `before-destroy` event prior to execution, and a `destroy` event upon completion.
     * 
     * No network request is made if it has not been persisted to the server. In this case, only
     * the `before-destroy` and `destroy` events will still fire (additionally passing `false`
     * as the second parameter to the callback) -- `sync` events will not.
     * 
     * @param {Function} [successFn] Called on save success: `successFn(model, response, status, xhr)`
     * @param {Object} [options={}] Options passed to `sync()`.
     * @returns {XMLHTTPRequest}
     */
    destroy: (successFn, options={}) ->
        unless typeof successFn is 'function'
            [options, successFn] = [successFn, null]
        options.success = [successFn, options.success]
        
        # Don't issue request if the server doesn't know about the model
        if @isNew()
            @trigger 'before-destroy', this, false
            for cb of options.success then cb?(this, false)
            @trigger 'destroy', this, false
            return false
        
        @sync 'delete', 'destroy', options
    
    
    
    /**
     * Execute a resource request. Adapted from `Backbone.sync`. Fires multiple events
     * during the request lifecycle:
     *  - `sync` 
     *  - `sync-#{action}`
     * 
     * TODO: Actually doc the events.
     * 
     * @returns {XMLHTTPRequest}
     */
    sync: (action, event, options={}) ->
        model   = this
        type    = ACTION_TO_METHOD[action]
        params  = { type, dataType:'json' }
        options = _.extend {}, DEFAULT_OPTIONS, options
        
        # Ensure that we have a URL.
        unless options.url
            params.url = _.result(model, 'url') or urlError()
        
        # Ensure that we have the appropriate request data.
        if not options.data and model and (action is 'create' or action is 'update')
            params.contentType = 'application/json'
            params.data        = JSON.stringify model
        
        # For older servers, emulate JSON by encoding the request into an HTML-form.
        if options.emulateJSON
            params.contentType = 'application/x-www-form-urlencoded'
            params.data        = if params.data then { model:that } else {}
        
        # For older servers, emulate HTTP by mimicking the HTTP method with `_method`
        # And an `X-HTTP-Method-Override` header.
        if setOverride = options.emulateHTTP and (type is 'PUT' or type is 'DELETE')
            params.type         = 'POST'
            params.data._method = type if options.emulateJSON
        
        beforeSendFn = options.beforeSend
        options.beforeSend  = (xhr) ->
            xhr.setRequestHeader 'X-HTTP-Method-Override', type if setOverride
            beforeSendFn? ...
            model.constructor.trigger?('before-sync', model, xhr, options)
        
        
        # Don't process data on a non-GET request.
        if params.type is not 'GET' and not options.emulateJSON
            params.processData = false
        
        successFns = options.success
        successFns = [successFns] unless _.isArray successFns
        options.success = (response, status, xhr) ->
            for cb of successFns
                cb?(model, response, status, xhr)
            model.trigger("sync-#action", model, response, options)
            model.trigger("sync", model, response, options)
            model.trigger(event, model)
            model.constructor.trigger?("sync", model, response, options)
        
        errorFn = options.error
        options.error = (xhr, status, errorThrown) ->
            errorFn?(model, errorThrown, status, xhr, options)
            model.trigger("sync-error-#action", model, xhr, options)
            model.trigger("sync-error", model, xhr, options)
            model.trigger("#event-error", model)
            model.constructor.trigger?("sync-error", model, xhr, options)
        
        # Trigger the `before` event.
        model.trigger("before-#event", model)
        
        # Make the request, allowing the user to override any Ajax options.
        Resource.ajax _.extend(params, options)
    
    
    
    
    # }}}
    /* * * *  Class Methods  * * * {{{ */
    
    # Make the class-object itself an event emitter.
    this import EventEmitter::
    
    /**
     * $.ajax() provider.
     */
    @$ = root.jQuery or root.Zepto or root.ender
    
    /**
     * Issue an ajax request.
     */
    @ajax = ->
        Resource.$.ajax.apply Resource.$, arguments
    
    # }}}

