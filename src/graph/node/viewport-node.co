_  = require 'underscore'
d3 = require 'd3'
ko = require 'knockout'
op = require 'operator'

{ GraphNodeData,
} = require './graph-node-data'
{ GraphNode,
} = require './graph-node'

Trait = require './graph-node-trait'


toNumeric = -> +it

cmpNumeric = (a, b) ->
    op.cmp +a, +b

tuplesEqual = (a, b) ->
    cmpNumeric(a[0], b[0]) is 0 and
    cmpNumeric(a[1], b[1]) is 0




/**
 * @namespace Default options for various scale types
 */
SCALE_DEFAULTS =
    ALL :
        clamp : false
        nice  : false
    time :
        # picks out a d3.time.interval for scale.nice()
        # := null | year | month | day | hour | minute | second | week == sunday | monday | tuesday | wednesday | thursday | friday | saturday
        # XXX: what happens if I pass an interval range, like d3.time.hour.range(2)
        interval : null
    pow :
        exponent : 1
    ordinal :
        round : true
        spacing : 0
        outerSpacing : 0
    # TODO: quantize, quantile; maybe threshold?



/**
 * @class
 * @extends GraphNodeData
 */
class exports.ViewportNodeData extends GraphNodeData
    @registerType 'viewport'
    
    defaults: ->
        width     : 'auto'
        minWidth  : 750
        maxWidth  : null
        
        height    : 500
        minHeight : 500
        maxHeight : null
        
        # scaleType {String} := null | "time" | "linear" | "log" | "sqrt" | "pow" | "ordinal"
        # Scale types defualt to a value based on introspection of the metric type:
        #   date/time               -> linear time scale
        #   int, float, numeric     -> linear quantitive scale
        #   string, *               -> ordinal scale
        
        x :
            scaleType : null
            padding   : 0
            domain    : null
        
        y :
            scaleType : null
            padding   : 0.1
            domain    : null
        
    
    attributeTypes: -> {}
    
    -> super ...



/**
 * @class
 * @extends GraphNode
 */
class exports.ViewportNode extends GraphNode
    @registerType 'viewport'
    traits : [
        Trait.VIEWPORT
        Trait.SVG
    ]
    tagName : 'g'
    
    
    
    /**
     * @constructor
     * @param {GraphView} graph
     * @param {GraphNodeData} model
     */
    (graph, model) ->
        super ...
        
        # Trigger resize whenever a child is added
        @on 'child-built', @resize, this
        $ window .resize _.debounce @resize.bind(this), 50ms
    
    
    
    
    
    /* * * *  Viewport Sizing  * * * {{{ */
    
    # TODO: use a responsive algo to pick good numbers based on screen/device
    defaultWidth     : @computed -> 750
    defaultMinWidth  : @computed -> 750
    defaultMaxWidth  : @computed -> Infinity
    defaultHeight    : @computed -> 500
    defaultMinHeight : @computed -> 500
    defaultMaxHeight : @computed -> Infinity
    
    fullWidth  : @computed -> if @el() and @_resizeProxy() and (w = @$el.innerWidth())  > 0 then w else @defaultWidth()
    fullHeight : @computed -> if @el() and @_resizeProxy() and (h = @$el.innerHeight()) > 0 then h else @defaultHeight()
    
    frameWidth : @computed ->
        return unless model = @model()
        v = model.width()
        if not v? or v is 'auto'
            min = model.minWidth() ? @defaultMinWidth()
            max = model.maxWidth() ? @defaultMaxWidth()
            v   = min >? @fullWidth() <? max
        v
    
    frameHeight : @computed ->
        return unless model = @model()
        v = model.height()
        if not v? or v is 'auto'
            min = model.minHeight() ? @defaultMinHeight()
            max = model.maxHeight() ? @defaultMaxHeight()
            v   = min >? @fullHeight() <? max
        v
    
    margin         : { top:30, right:60, bottom:30, left:60 }
    viewportWidth  : @computed -> @frameWidth()  - @margin.left - @margin.right
    viewportHeight : @computed -> @frameHeight() - @margin.top  - @margin.bottom
    
    clipWidth      : @computed -> if (v = @viewportWidth())  > 0 then v else @defaultWidth()
    clipHeight     : @computed -> if (v = @viewportHeight()) > 0 then v else @defaultHeight()
    
    width          : @computed -> @clipWidth()
    height         : @computed -> @clipHeight()
    center         : @computed -> [ @width()/2, @height()/2 ]
    
    
    
    # }}}
    /* * * *  Metrics  * * * {{{ */
    
    /**
     * Child nodes that are not children of another viewport node.
     * @type ko.computed<GraphNode>
     */
    viewportChildren: @computed ->
        children = []
        unvisited = @children().slice()
        while node = unvisited.shift()
            children.push node
            continue if node.hasTrait Trait.VIEWPORT
            unvisited .= concat node.children() # note: circular refs in a tree should be impossible
        children
    
    
    
    /**
     * @protected
     * @param {Array<GraphNode>} nodes
     * @returns {Array<Metric>} Metrics of valid, enabled nodes.
     */
    _metricsFrom: (nodes) ->
        metrics = _.reduce_ nodes, [], (metrics, node) ->
            if      node.hasTrait(Trait.REQUIRES_METRIC) and
                    node.hasTrait(Trait.METRIC_CONTENT_DATA) and
                    not node.disabled() and
                    metric = node.model()?.metric()
                metrics.push metric
            metrics
        return if metrics.length then metrics else null
        
    
    /**
     * All content-data metrics under this viewport.
     * @type ko.computed<Array<Metric>>
     */
    allMetrics: @computed ->
        @_metricsFrom @map op.I
    
    
    /**
     * Content-data metrics under this viewport not under another viewport.
     * @type ko.computed<Array<Metric>>
     */
    viewportMetrics: @computed ->
        @_metricsFrom @viewportChildren()
    
    
    xValues: @computed ->
        return unless metrics = @allMetrics()
        _.flatten _.compact _.invoke metrics, 'xValues'
    
    
    yValues: @computed ->
        return unless metrics = @allMetrics()
        _.flatten _.compact _.invoke metrics, 'yValues'
    
    
    
    # }}}
    /* * * *  Scales  * * * {{{ */
    
    
    xScale: @computed ->
        return null unless xScale = @createScale @xScaleType()
        xScale.domain that if @xDomain()
        xScale.range [0, @viewportWidth()]
    
    
    yScale: @computed ->
        return null unless yScale = @createScale @yScaleType()
        yScale.domain that if @yDomain()
        yScale.range [@viewportHeight(), 0]
    
    
    xDomain: @computed ->
        @_domainFor 'x'
    
    
    yDomain: @computed ->
        return unless yDomain = @_domainFor 'y'
        # FIXME: hack to render log-scales when some input values are <= 0
        yDomain[0] = 0.01 if @yScaleType() is 'log' and yDomain[0] < 1
        yDomain
    
    
    _domainFor: (dim) ->
        values = @["#{dim}Values"]() # always create a dependency on the values
        domain = @model().get "#dim.domain"
        unless _.isArray(domain) and domain.length is 2 and _.every(domain, isFinite)
            return unless values?.length
            domain = @applyPadding d3.extent(values), @model().get("#dim.padding")
        domain
    
    
    /**
     * @type ko.computed<String := time | linear | log | sqrt | pow | ordinal>
     */
    xScaleType: @computed ->
        @model().get('x.scaleType') or @_scaleTypeFor('xType')
    
    
    /**
     * @type ko.computed<String := time | linear | log | sqrt | pow | ordinal>
     */
    yScaleType: @computed ->
        @model().get('y.scaleType') or @_scaleTypeFor('yType')
    
    
    /**
     * @private
     * @param {String} typeDimension 'xType' or 'yType'
     * @returns {String := time | linear | log | sqrt | pow | ordinal}
     */
    _scaleTypeFor: (typeDimension) ->
        return null unless metrics = @viewportMetrics()
        types = _ metrics .chain()
            .invoke typeDimension
            .compact()
            .map ->
                switch it .= toLowerCase()
                case 'linear' 'log' 'sqrt' 'pow'    then it
                case 'int' 'float' 'number'         then 'linear'
                case 'time' 'date'                  then 'time'
                # includes ordinal, string
                default                             then 'ordinal'
            .uniq()
            .value()
        if types.length > 1
            throw new Error "Invalid Graph: Multiple scale types specified by children for #typeDimension! #{JSON.stringify types}"
        types[0]
    
    
    createScale: (type, props={}) ->
        return null unless type
        scale = switch type
            case 'time'
                d3.time.scale().clamp(true)
            case 'linear' 'log' 'sqrt' 'pow'
                d3.scale[type]()
            case 'ordinal'
                d3.scale.ordinal()
            default
                throw new Error "Unknown scale type #type!"
        for k, v in props
            scale[k] v
        scale
    
    
    makeScaleShape: (shape) ->
        xScale = @xScale()
        yScale = @yScale()
        unless xScale and yScale
            throw new Error "Cannot make scale shape '#shape'! xScale=#{typeof xScale}; yScale=#{typeof yScale}"
        switch shape
        case 'area'
            d3.svg.area()
                .x  ([date, val], i) ~> xScale date
                .y1 ([date, val], i) ~> yScale val
                .y0 yScale.range()[0]
                # .defined @isDataInView.bind this
                .defined ([x,y])    ~> isFinite yScale y
                .interpolate 'linear'
        default
            d3.svg.line()
                .x ([date, val], i) ~> xScale date
                .y ([date, val], i) ~> yScale val
                # .defined @isDataInView.bind this
                .defined ([x,y])    ~> isFinite yScale y
                .interpolate 'linear'
    
    
    isDataInView: ([x, y]) ->
        [xMin, xMax] = @xDomain().map toNumeric
        return  xMin <= +x <= xMax and
            isFinite @yScale() y
    
    
    applyPadding: (ext, p) ->
        isDate     = ext.map -> it instanceof Date
        [min, max] = ext.map toNumeric
        min -= min * p
        max += max * p
        [min, max].map (v, i) -> if isDate[i] then new Date(v) else v
    
    
    
    # }}}
    /* * * *  Rendering  * * * {{{ */
    
    
    buildElement: (parentElement) ->
        el = super ...
        @trackCursor()
        el
    
    
    
    # }}}
    /* * * *  Viewport Events  * * * {{{ */
    
    
    /**
     * Trigger recalculation of values that depend on window size.
     */
    resize : -> @_resizeProxy {} if @el.peek()
    
    
    /**
     * Observable used to recalculate on changes to window size.
     * 
     * @protected
     * @type ko.observable<Object>
     */
    _resizeProxy : ko.observable {}
    
    
    /**
     * Current location of the cursor in the viewport.
     * @type ko.observable<Object>
     */
    cursor: ko.observable null
    
    
    trackCursor: ->
        return if @cursor.peek() # only initialize once
        return unless el  = @el.peek()
        return unless svg = _.toElement @graph.$('svg')
        svg = d3.select svg
        
        svg.on 'mouseover', ~>
            [x, y] = d3.mouse(el)
            cursor = { +hovering, x, y }
            @trigger 'mouseover', cursor, this
            # cursor observable will be handled by mousemove
        
        svg.on 'mousemove', ~>
            [x, y] = d3.mouse(el)
            cursor = { +hovering, x, y }
            @trigger 'mousemove', cursor, this
            with @cursor.peek()
                @cursor cursor if not &?.hovering or &x != x or &y != y
        
        svg.on 'mouseout', ~>
            [x, y] = d3.mouse(el)
            @cursor cursor = { -hovering, x, y }
            @trigger 'mouseout', cursor, this
        
        this
    
    
    /**
     * Broadcast a zoom event.
     */
    zooming: (translate, scale) ->
        @trigger 'zoom-graph', translate, scale, this
    
    
    # }}}
    /* * * *  Watchers  * * * {{{ */
    
    watchDeps: ->
        @allMetrics()
    
    
    watchOthers: ->
        @xValues(); @xDomain(); @xScale()
        @yValues(); @yDomain(); @yScale()
    
    
    
    # }}}
    

