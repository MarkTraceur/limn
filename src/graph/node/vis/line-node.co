_  = require 'underscore'
ko = require 'knockout'
d3 = require 'd3'

{ TimeseriesNode,
} = require './timeseries-node'

Trait = require '../graph-node-trait'



/**
 * @class
 * @extends TimeseriesNode
 */
class exports.LineNode extends TimeseriesNode
    nodeType : 'line'
    traits   : [
        Trait.VIS_NODE
        Trait.REQUIRES_METRIC
        Trait.METRIC_TIMESERIES
        Trait.LEAF
    ]
    @registerType()
    
    
    # buildElement: (parentElement) ->
    #     super parentElement
    
    
    -> super ...
    
    buildElement: (parentElment) ->
        el = super ...
        @line()
        el
    
    line: @computed ->
        return null unless @el() and @sel
        
        model  = @model()
        metric = model?.metric()
        data   = if metric?.data() then [that] else []
        
        line = @selectAll 'path.metric-line' .data data
        line.enter()
            .append 'path'
                .classed 'metric-line', true
                .attr  'vector-effect', 'non-scaling-stroke'
                .style 'fill',          'none'
                .style 'stroke-width',  5
                .style 'stroke',        model.options().get('color') or 'skyblue'
                # .style 'stroke', ~> @chart.colorScale @columnHeader()
                # .attr 'data-metricIndex', @columnHeader()
        
        line.exit()
            .remove()
        
        line.transition()
            .attr 'd', @root().makeLine
        
        line
    
    
    
    
    
    /*
    build: (parentElement) ->
        @sel = parentElement.append 'g'
        
        # make sure we can receive updates before we broadcast the metric
        @chart.scales.subscribe (updated) ~>
            @renderLine.call this if updated
        
        @chart.metrics.push(this)
        
        @sel.append 'path'
            .classed 'metric-line', true
            .style 'stroke-width', 5
            .style 'fill', 'none'
            .attr 'vector-effect', 'non-scaling-stroke'
    
    */
