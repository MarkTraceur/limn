_  = require 'underscore'
ko = require 'knockout'
d3 = require 'd3'

{ TimeseriesNode, TimeseriesNodeData,
} = require './timeseries-node'
{ TimeseriesMetric,
} = require '../../../data/metric'

Trait = require '../graph-node-trait'
ProjectColors = require '../../project-colors'



/**
 * @class
 * @extends TimeseriesNodeData
 */
class exports.LineNodeData extends TimeseriesNodeData
    @registerType 'line'
    
    defaults: ->
        options :
            label       : null
            color       : null
            stroke      : null
            noLegend    : false
    
    attributeTypes: ->
        metric : TimeseriesMetric
    
    -> super ...



/**
 * @class
 * @extends TimeseriesNode
 */
class exports.LineNode extends TimeseriesNode
    @registerType 'line'
    traits : [
        Trait.VIS_NODE
        Trait.REQUIRES_METRIC
        Trait.METRIC_CONTENT_DATA
        Trait.METRIC_TIMESERIES
        Trait.SVG
        Trait.LEAF
    ]
    
    
    ->
        super ...
        @trackHover()
    
    
    trackHover: @computed ->
        return unless cursor = @root().cursor()
        return unless @model().metric()?.data()?.length
        return unless @sel
        
        @trackingCircle ?= @sel.append 'circle'
            .classed 'tracking', true
            .style do
                fill: @color()
            .attr do
                r: 5
        
        cx = -10
        cy = -10
        
        if cursor.hovering and not @disabled()
            date = @root().xScale.invert cursor.x
            closest = @model().metric().findClosest date
            
            cx = @root().xScale closest.date
            cy = @root().yScale closest.value
            
            unless isFinite cx and isFinite cy
                cx = -10
                cy = -10
        
        @trackingCircle.attr do
            cx: cx
            cy: cy
    
    color: @computedRequires 'model.options', (options) ->
        # FIXME: why is the color not converted into an observable?
        ProjectColors.lookup(@shortLabel(), @palette()) or options.stroke?()?.color or 'black'
    
    width: @computedRequires 'model.options', (options) ->
        options.stroke?()?.width?() or 3
    
    dasharray: @computedRequires 'model.options', (options) ->
        options.stroke?()?.dashed?() or 'none'
    
    /**
     * Update selection representing the SVG path element for the line.
     * @type ko.computed<d3.selection.update>
     */
    render: ->
        data = if @timeseriesData() then [that] else []
        
        return null unless data.length
        return null unless model  = @model()
        return null unless scales = @root().scales()
        
        shape = @parent().options?().shape?() or 'line'
        color = @color()
        
        if shape is 'bar'
            data = data[0]
            bar = @selectAll 'rect.metric-bar' .data data
            
            # always exit() to remove existing nodes if data has changed and become invalid
            bar.exit().remove()
            
            yScale = @root().scales().yScale
            yRange = yScale.range()
            
            xScale = @root().scales().xScale
            xRange = xScale.range()
            width = Math.floor((xRange[1] - xRange[0]) / data.length * 0.5)
            offset = width / 2
            
            rect = bar.enter()
                .append 'rect'
                    .classed 'metricBar', true
                    .attr 'y', (d) -> yScale(d[1])
                    .attr 'x', (d, i) -> xScale(d[0]) - offset
                    .attr 'width', width
                    .attr 'height', (d) -> yRange[0] - yScale(d[1])
                    .style 'stroke', color
                    .style 'fill', color
            bar
        
        else if shape is 'line' or shape is 'area'
            line = @selectAll 'path.metric-line' .data data
            
            # always exit() to remove existing nodes if data has changed and become invalid
            line.exit().remove()
            
            path = line.enter()
                .append 'path'
                    .classed 'metric-line',     true
                    .attr  'vector-effect',     'non-scaling-stroke'
                    .style 'fill',              'none'
                    .style 'stroke-dasharray',  @dasharray()
                    .style 'stroke-width',      @width()
                    .style 'stroke',            color
            if shape is 'area'
                path
                    .style 'fill',              color
                    .style 'opacity',           0.4
            
            line.style 'visibility', if @disabled() then "hidden" else "visible"
            line.transition()
                .attr 'd', scales.scaleShape(shape)
            line
