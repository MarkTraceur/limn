_  = require 'underscore'
ko = require 'knockout'

unwrap = ko.utils.unwrapObservable

{ Base,
} = require '../../base/base'
{ OrderedSet,
} = require '../../util'


/**
 * Name of the property for a node subclass's type-name.
 * @constant
 * @type String
 */
NODE_TYPENAME_KEY = exports.NODE_TYPENAME_KEY = 'nodeType'

/**
 * Map of known GraphNode types, keyed by type-name.
 * @type Map<String, Class<GraphNode>>
 */
NODE_TYPES = exports.NODE_TYPES = {}


/**
 * @class Handles the presentation of a specific type of visualization element in a Graph.
 * @extends Base
 */
class exports.GraphNode extends Base
    
    /**
     * @section Class Properties
     * Properties shared across all instances by virtue of the prototype;
     * it is expected instances will not [need to] modify these values.
     */
    
    /**
     * Unique id for this GraphNode type, as referenced by `GraphNodeData::nodeType`.
     * 
     * Required to be set by all subclasses; afterward, notify the GraphNode registry
     * to provide the type for rendering:
     * 
     *  class AnotherGraphNode extends GraphNode
     *      nodeType : 'another'
     *      @registerType()
     *      -> ...
     * 
     * @type String
     */
    nodeType : null
    
    
    /**
     * Characteristics of this node-type; utilized by the Graph's Display and Edit views
     * to customize default behavior of nodes, as well as filter, group, and order their
     * DOM nodes.
     * 
     * @see limn.graph.NodeTraits
     * @type Array<String>
     */
    traits : <[  ]>
    
    
    
    /* * * *  Instance Properties  * * * {{{ */
    
    /**
     * The GraphView for this node tree.
     * @type GraphView
     */
    graph : null
    
    /**
     * Observable properties and their defaults.
     * 
     * Recall these properties are attached directly to the instance so long
     * as there is no conflict; the fact that they are also stored
     * in `@attributes` is not important to GraphNode.
     */
    defaults: ->
        el          : null
        model       : null
        parent      : null
        children    : []
        isDestroyed : false
    
    attributeTypes:
        children : (nodeData, parent=this) ->
            @graph.lookupNode nodeData, parent
    
    /**
     * Model data for this node.
     * @type ko.observable<GraphNodeData>
     */
    model : null
    
    /**
     * Parent of this node.
     * @type ko.observable<GraphNode>
     */
    parent : null
    
    /**
     * Used to synchronize model GraphNodeData children with our GraphNode children.
     * @protected
     * @type OrderedSet<GraphNodeData>
     */
    childNodeData : null
    
    /**
     * Used to synchronize model GraphNodeData children with our GraphNode children.
     * @protected
     * @type OrderedSet<GraphNode>
     */
    childNodes : null
    
    /**
     * Synchronizes model GraphNodeData children with our GraphNode children.
     * @type ko.observableArray<GraphNode>
     */
    syncChildren : @eagerComputed ->
        parent      = this
        graph       = @graph
        
        childNodes = @childNodes
        oldNodeData = @childNodeData
        currentNodeData = @childNodeData = new OrderedSet().update @model().children()
        
        changes = []
        
        # figure out which nodes have been removed; toArray() so we can mutate the set
        for oldIdx, data of oldNodeData.toArray()
            node    = graph.lookupNode data, parent
            oldNode = childNodes.find -> it.model() is data
            
            # Ensure the GraphNode we're working with is current for this data
            if oldNode is not node
                @children.remove oldNode
            
            # Immediately remove missing nodes
            continue if currentNodeData.has data
            changes.push { state:'removed', node, data, oldIdx, newIdx:-1 }
            @children.remove node
            # FIXME: unparent
            # TODO: emit change events somewhere
        
        # now determine what needs to be added, and otherwise what needs moving
        for newIdx, data of currentNodeData
            node = graph.lookupNode data, parent
            oldIdx = oldNodeData.indexOf data
            
            # states: unchanged, moved, new, removed
            if oldIdx is -1
                state = 'new'
                # FIXME: unparent from old node, set new parent
                # FIXME: move node.el between DOM parents? -- ...no, that should be a computed somewhere else
            else if oldIdx is not newIdx
                state = 'moved'
                # FIXME: reorder node.el? -- ...no, that should be a computed somewhere else
            else
                state = 'unchanged'
            
            changes.push { state, node, data, oldIdx, newIdx }
            # TODO: emit change events somewhere
        
        @children.splice 0, @children().length, ...@childNodes.values()
    
    /**
     * DOM Element at the root of this Node. jQuery objects and d3 Selections
     * will be automatically stripped of their wrappers.
     * @type ko.observable<Element>
     */
    el : @eagerCoerciveComputed (el) ->
        @$el = @sel = null
        el = el[0]      if el instanceof jQuery
        el = el.node()  if el instanceof d3.selection
        return el       unless _.isElement el
        @$el = $ el
        @sel = d3.select el
        el
    
    /**
     * jQuery-wrapped root element.
     * @type jQuery
     */
    $el : null
    
    /**
     * Selection of the element for this view, used by @select() and @selectAll().
     * Defaults to `d3.select(this.el)`.
     * @type d3.selection
     */
    sel : null
    
    
    # }}}
    
    
    
    
    /**
     * @constructor
     * @param {GraphNodeData} model
     * @param {GraphNode} parent
     * @param {GraphView} [graph=parent.graph]
     */
    (model, parent, graph) ->
        unless @graph = graph or parent?.graph
            throw new Error "GraphNode has 'Graph' in it for a reason. Supply one, clown! (got #{@graph})"
        
        @childModels = new OrderedSet()
        @childNodeData = new OrderedSet()
        @childNodes  = new OrderedSet()
        super { model, parent }
        
        # Useful for providing IDs to things that care, like text-inputs
        # so you can use label(for=id).
        @graphId = 'graph-' + @graph.__id__
        @nodeId  = 'graph-node-' + @__id__
        
        # Add the model's attributes to this node (where they don't overlap)
        _.defaults this, model.attributes if model?.attributes
        
        @parent.onChange (oldParent, newParent) ~>
            
        
    
    
    
    /* * * *  GraphNode API  * * * {{{ */
    
    /**
     * Optional hook to initialize the node once construction is complete.
     * @abstract
     * @returns {this}
     */
    init: -> this
    
    /**
     * Implement to completely customize the process of building the DOM nodes
     * for the presentation of this GraphNode.
     * 
     * @param {Element} parentElement Parent DOM element (and can be either
     *  an HTML or an SVG element).
     * @returns {Element} Newly constructed root element for this GraphNode.
     */
    build: (parentElement) ->
        
    
    
    buildElement: ->
        @createElement @tagName, { class:@cssClasses }
    
    
    /**
     * Performs a depth-first walk across the tree of GraphNodes, invoking an
     * iteration function much like  `Array.reduce`, passing a custom "accumulator"
     * value along with the current node: 
     * 
     *  `newAcc = fn.call(context, currentAcc, node)`
     * 
     * The iterator's return becomes the new accumulator. If not specified, the
     * iterator will be invoked with the node as the context.
     * 
     * @param {*} acc Starting accumulator value.
     * @param {Object} [context=this] Execution context for the iteration function.
     * @param {Function} fn Iteration function.
     * @returns {*} Final accumulator value.
     */
    walk: (acc, cxt, fn) ->
        [fn, cxt] = [cxt, null] unless typeof fn is 'function'
        acc = fn.call(cxt or this, acc, this)
        for childNode of @children().slice()
            acc = childNode.walk acc, cxt, fn
        acc
    
    
    
    
    addChild: (childNode) ->
        return childNode if @childNodes
    
    
    removeChild: ->
        
    
    
    /**
     * Recursively create GraphNodes for the model's GraphNodeData objects.
     */
    populate: ->
        parent   = this
        children = @children()
        for nodeData of @model().children().slice()
            children.push childNode = GraphNode.fromNodeData parent, nodeData
            # childNode.populate()
        this
    
    
    /**
     * Call when disposing of this node.
     * @returns {this}
     */
    destroy: ->
        return this if @isDestroyed()
        @isDestroyed true
        @trigger 'destroy', this
        this
    
    
    
    # }}}
    /* * * *  Property Cascading  * * * {{{ */
    
    # TODO
    
    # }}}
    ### DOM Helpers {{{
    
    $: ->
        @$el?.find.apply @$el, arguments
    
    
    select: (selector) ->
        @sel?.select selector
    
    
    selectAll: (selector) ->
        @sel?.selectAll selector
    
    
    /**
     * Creates elements with the correct namespace for both HTML and SVG tags.
     */
    createElement : (tagName, attributes) ->
        range = document.createRange()
        range.selectNode document.body
        el = range.createContextualFragment("<#tagName/>").childNodes[0]
        $(el).attr attributes if attributes
        el
    
    
    # }}}
    /* * * *  Class Methods  * * * {{{ */
    
    
    /**
     * Register a new chart type. Subclasses should only call this
     * method *after* setting their `nodeType`:
     * 
     *  class AnotherGraphNode extends GraphNode
     *      nodeType : 'another'
     *      @registerType()
     *      
     *      -> ...
     * 
     * @static
     * @protected
     */
    @registerType = (Subclass=this) ->
        # console.log "GraphNode.registerType(#Subclass)"
        unless Subclass?::?.hasOwnProperty(NODE_TYPENAME_KEY) and nodeType = Subclass::[NODE_TYPENAME_KEY]
            throw new Error "GraphNode sub-types must declare a new, unique nodeType on the prototype! (got #{Subclass?::?[NODE_TYPENAME_KEY]})"
        if NODE_TYPES[nodeType]
            throw new Error "Duplicate GraphNode nodeType! (got #nodeType)"
        NODE_TYPES[nodeType] = Subclass
    
    
    /**
     * Look up a `GraphNode` by `nodeType`.
     * @static
     */
    @lookupType = (nodeType) ->
        nodeType = unwrap _.result nodeType, NODE_TYPENAME_KEY unless typeof nodeType is 'string'
        unless GraphNodeType = NODE_TYPES[nodeType]
            throw new Error "Unknown GraphNode type '#nodeType'!"
        GraphNodeType
    
    
    /**
     * Constructs a new `GraphNode` of this class's type without regard
     * for the `nodeType` specified by the `GraphNodeData`.
     * 
     * If omitted, the `GraphView` for the new node will be inherited
     * from the parent node.
     * 
     * @static
     * @param {GraphNode} parent
     * @param {GraphNodeData} model
     * @param {GraphView} [graph=parent.graph]
     * @returns {? extends GraphNode} A new GraphNode instance.
     */
    @create = (model, parent, graph) ->
        GraphNodeType = this
        new GraphNodeType model, parent, graph
    
    
    /**
     * Constructs a new `GraphNode` of the appropriate type for the
     * given `GraphNodeData`; the `GraphView` for the new node will
     * be inherited from the parent node.
     * 
     * @static
     * @param {GraphNodeData} model 
     * @param {GraphNode} parent 
     * @param {GraphView} [graph=parent.graph]
     * @returns {? extends GraphNode} The GraphNode instance.
     */
    @fromNodeData = (model, parent, graph) ->
        return null  unless model?
        return model if model instanceof GraphNode
        GraphNodeType = GraphNode.lookupType model
        new GraphNodeType model, parent, graph
    
    
    # }}}
    

