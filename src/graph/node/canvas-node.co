d3 = require 'd3'
ko = require 'knockout'

{ GraphNode,
} = require './graph-node'

Trait = require './graph-node-trait'



/**
 * @class
 * @extends GraphNode
 */
class exports.CanvasNode extends GraphNode
    nodeType : 'canvas'
    traits   : [ Trait.META_NODE, Trait.VIEWPORT, ]
    @registerType()
    
    template: 'canvas-node'
    
    
    /* * * *  Viewport Sizing  * * * {{{ */
    
    # TODO: use a responsive algo to pick good numbers based on screen/device
    defaultWidth  : @computed -> 750
    defaultHeight : @computed -> 500
    
    fullWidth    : @computed -> @$el.innerWidth()  if @el()
    fullHeight   : @computed -> @$el.innerHeight() if @el()
    
    margin : { top:30, right:60, bottom:30, left:60 }
    
    frameWidth : @computed ->
        return @defaultWidth() unless model = @model()
        width = model.width()
        if width is 'auto'
            width = @fullWidth() or @defaultWidth()
        width
    
    frameHeight : @computed ->
        return @defaultHeight() unless model = @model()
        height = model.height()
        if height is 'auto'
            height = @fullHeight() or @defaultHeight()
        height
    
    viewportWidth : @computed ->
        @frameWidth() - @margin.left - @margin.right
    
    viewportHeight : @computed ->
        @frameHeight() - @margin.top - @margin.bottom
    
    
    
    
    
    # }}}
    
    
    /**
     * The scale that translates x domain values into x output range values
     * @type d3.time.scale
     */
    xScale : null
    
    /**
     * The x domain materialized as a finite array
     * @type Array<Number>
     */
    xSteps : null
    
    /**
     * The x output range distance between two x domain values.
     * Dynamically calculated to spread just enough xSteps over the x output range.
     */
    xStep : 0
    
    /**
     * The x output range distance which is "close enough" to an xStep
     */
    dx : 0
    
    /**
     * The scale that translates y domain values into y output range values
     */
    yScale: null
    yTicks: null
    
    /**
     * The domain of @see yScale needs to be kept separately so we can add padding that takes into account all metrics
     */
    yDomain: null
    
    
    metrics : @computed ->
        metrics = @walk [], (metrics, node) ->
            if node.hasTrait(Trait.REQUIRES_METRIC) and metric = node.model().metric()
                metrics.push metric
            metrics
        
        xDomain = d3.extent _.flatten _.invoke metrics, 'dates'
        @xScale().domain xDomain
        
        yDomain = d3.extent _.flatten _.invoke metrics, 'values'
        @yScale().domain yDomain.reverse()
        
        # if metrics.length > 0
        #     @xSteps metrics.dates()
        #     true
        # else
        #     false
        metrics
    
    
    /**
     * @constructor
     * @param {GraphView} graph
     * @param {GraphNodeData} model
     */
    (graph, model) ->
        @xScale = d3.time.scale().clamp(true)
        @yScale = d3.scale.log()
        @makeLine = d3.svg.line()
            .x ([date, val], i) ~> @xScale date # TODO: assumes all metrics have the same x domain
            .y ([date, val], i) ~> @yScale val
            .interpolate 'linear'
        super ...
    
    
    buildElement: (parentElement) ->
        $parent = $ parentElement .attr 'data-bind', 'template: { name:template, data:$data }'
        ko.applyBindings this, $parent.0
        $parent.find('.canvas-node.graph-node').0
    
    
    determineDOMParentForChildNode: (node) ->
        # TODO: better handle html vs svg
        # TODO: handle fg/bg
        if _.all [ Trait.META_NODE, Trait.HTML ], _.contains.bind(_, node.traits)
            @$ 'section.meta' .0
        else
            @$ 'g.viewport' .0
