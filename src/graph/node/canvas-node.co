_  = require 'underscore'
d3 = require 'd3'
ko = require 'knockout'

{ GraphNode,
} = require './graph-node'

Trait = require './graph-node-trait'



/**
 * @class
 * @extends GraphNode
 */
class exports.CanvasNode extends GraphNode
    nodeType : 'canvas'
    traits   : [ Trait.VIEWPORT ]
    @registerType()
    
    tagName : 'section'
    template: 'canvas-node'
    
    
    /* * * *  Viewport Sizing  * * * {{{ */
    
    # TODO: use a responsive algo to pick good numbers based on screen/device
    defaultWidth  : @computed -> 750
    defaultHeight : @computed -> 500
    
    _sizeProxy    : ko.observable {}
    resize        : -> @_sizeProxy {}
    
    fullWidth     : @computed -> @$el.innerWidth()  if @el() and @_sizeProxy()
    fullHeight    : @computed -> @$el.innerHeight() if @el() and @_sizeProxy()
    
    margin : { top:30, right:60, bottom:30, left:60 }
    
    frameWidth : @computed ->
        return unless model = @model()
        width = model.width()
        if width is 'auto'
            width = @fullWidth()
        width
    
    frameHeight : @computed ->
        return unless model = @model()
        height = model.height()
        if height is 'auto'
            height = @fullHeight()
        height
    
    viewportWidth : @computed ->
        @frameWidth() - @margin.left - @margin.right
    
    viewportHeight : @computed ->
        @frameHeight() - @margin.top - @margin.bottom
    
    width  : @computed -> @viewportWidth()
    height : @computed -> @viewportHeight()
    
    
    # }}}
    /* * * *  Scales  * * * {{{ */
    
    /**
     * The scale that translates x domain values into x output range values
     * @type d3.time.scale
     */
    xScale : null
    
    /**
     * The x output range distance which is "close enough" to an xStep
     */
    dx : 0
    
    /**
     * The scale that translates y domain values into y output range values
     */
    yScale : null
    
    padding : 0.1
    
    applyPadding: ([min, max]) ->
        min -= min * @padding
        max += max * @padding
        [min, max]
    
    
    /**
     * Observable for the contents of xScale and yScale, tracking their changes.
     * @type ko.observable<Object>
     */
    scales : ko.observable null
    
    /**
     * @returns {false|Object} The scales object if all are valid; false otherwise.
     */
    scalesIfValid: @computed ->
        scales = @scales()
        return scales if scales?.xValid and scales.yValid
        false
    
    
    /**
     * Recomputes the scale values.
     * @type Array<Metric>
     */
    metrics : @computed ->
        metrics = @walk [], (metrics, node) ->
            if node.hasTrait(Trait.REQUIRES_METRIC) and metric = node.model.peek().metric()
                metrics.push metric
            metrics
        
        # Grab old values for comparison so only mutate @scales when something has changed
        _scales  = @scales.peek()
        _xDomain = @xScale.domain()
        _yDomain = @yScale.domain()
        _width   = @xScale.range()[1]
        _height  = @yScale.range()[1]
        
        # Update each scale using metrics
        xs = _.compact _.flatten _.invoke metrics, 'dates'
        xDomain = d3.extent xs
        @xScale.domain xDomain if xs.length
        
        width = @viewportWidth()
        @xScale.range [0, width]
        
        xValid = xs.length and width > 0
        
        ys = _.compact _.flatten _.invoke metrics, 'values'
        yDomain = @applyPadding d3.extent ys
        @yScale.domain yDomain if ys.length
        
        height = @viewportHeight()
        @yScale.range [height, 0]
        
        yValid = ys.length and height > 0
        
        # If anything changed, trigger a notification by setting the scales computed
        if      xDomain[0] != _xDomain[0] or xDomain[1] != _xDomain[1]   or
                yDomain[0] != _yDomain[0] or yDomain[1] != _yDomain[1]   or
                width      != _width      or height     != _height
            @scales { @xScale, @yScale, @scaleLine, xValid, yValid }
        
        metrics
    
    
    # }}}
    
    
    
    /**
     * @constructor
     * @param {GraphView} graph
     * @param {GraphNodeData} model
     */
    (graph, model) ->
        super ...
        @xScale = d3.time.scale().clamp(true)
        @yScale = d3.scale.log()
        @scaleLine = d3.svg.line()
            .x ([date, val], i) ~> @xScale date # TODO: assumes all metrics have the same x domain
            .y ([date, val], i) ~> @yScale val
            .interpolate 'linear'
        @scales { @xScale, @yScale, @scaleLine, -xValid, -yValid }
        
        # Trigger resize whenever a child is added
        @on 'child-built', @resize, this
    
    
    /**
     * Hooks into the `@watch()` trigger.
     */
    watchOthers: ->
        @metrics()
    
    
    buildElement: (parentElement) ->
        @renderView parentElement
        @el el = $(parentElement).find('.canvas-node.graph-node').0
        el
    
    
    determineDOMParentForChildNode: (node) ->
        # SVG nodes
        if node.hasTrait Trait.SVG
            if node.hasTrait Trait.FG_LAYER
                @$ 'svg > g > g.fg' .0
            else if node.hasTrait Trait.BG_LAYER
                @$ 'svg > g > g.frame > g.bg' .0
            else
                @$ 'svg > g > g.frame > g.viewport' .0
        
        # HTML nodes
        else
            # XXX: Hack
            if node.hasTrait Trait.CALLOUT_NODE
                @graph.$ '.graph-name-row > section.callout' .0
            else if node.hasTrait Trait.SECTION
                @$el.parent().0
            else if node.hasTrait Trait.FG_LAYER
                @$ 'section.meta.fg' .0
            else
                @$ 'section.meta.bg' .0
    
    
    
    

