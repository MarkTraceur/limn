_  = require 'underscore'
d3 = require 'd3'
ko = require 'knockout'

{ GraphNode,
} = require './graph-node'

Trait = require './graph-node-trait'



/**
 * @class
 * @extends GraphNode
 */
class exports.CanvasNode extends GraphNode
    nodeType : 'canvas'
    traits   : [ Trait.VIEWPORT ]
    @registerType()
    
    template: 'canvas-node'
    
    
    /* * * *  Viewport Sizing  * * * {{{ */
    
    # TODO: use a responsive algo to pick good numbers based on screen/device
    defaultWidth  : @computed -> 750
    defaultHeight : @computed -> 500
    
    fullWidth    : @computed -> @$el.innerWidth()  if @el()
    fullHeight   : @computed -> @$el.innerHeight() if @el()
    
    margin : { top:30, right:60, bottom:30, left:60 }
    
    frameWidth : @computed ->
        return @defaultWidth() unless model = @model()
        width = model.width()
        if width is 'auto'
            width = @fullWidth() or @defaultWidth()
        width
    
    frameHeight : @computed ->
        return @defaultHeight() unless model = @model()
        height = model.height()
        if height is 'auto'
            height = @fullHeight() or @defaultHeight()
        height
    
    viewportWidth : @computed ->
        @frameWidth() - @margin.left - @margin.right
    
    viewportHeight : @computed ->
        @frameHeight() - @margin.top - @margin.bottom
    
    width  : @computed -> @viewportWidth()
    height : @computed -> @viewportHeight()
    
    
    # }}}
    /* * * *  Scales  * * * {{{ */
    
    /**
     * The scale that translates x domain values into x output range values
     * @type d3.time.scale
     */
    xScale : null
    
    /**
     * The x output range distance which is "close enough" to an xStep
     */
    dx : 0
    
    /**
     * The scale that translates y domain values into y output range values
     */
    yScale : null
    yTicks : null
    
    /**
     * Changes the yScale to pad the edges; expressed as a fraction of the domain's
     * extents.
     * @type Number
     */
    scaleBuffer : 0.1
    
    /**
     * Observable for the contents of xScale and yScale, tracking their changes.
     * @type ko.observable<Object>
     */
    scales : ko.observable null
    
    /**
     * Recomputes the scale values.
     * @type Array<Metric>
     */
    metrics : @computed ->
        metrics = @walk [], (metrics, node) ->
            if node.hasTrait(Trait.REQUIRES_METRIC) and metric = node.model.peek().metric()
                metrics.push metric
            metrics
        
        # grab old values for comparison so only mutate @scales when something has changed
        _xDomain = @xScale.domain()
        _yDomain = @yScale.domain()
        _width   = @xScale.range()[1]
        _height  = @yScale.range()[1]
        
        xs = _.compact _.flatten _.invoke metrics, 'dates'
        xDomain = d3.extent xs
        @xScale.domain xDomain
        width = @viewportWidth() if xs.length
        @xScale.range [0, width]
        
        ys = _.compact _.flatten _.invoke metrics, 'values'
        yDomain = d3.extent ys
        if ys.length
            yDomain[0] -= @scaleBuffer * yDomain[0]
            yDomain[1] += @scaleBuffer * yDomain[1]
            @yScale.domain yDomain
        height = @viewportHeight()
        @yScale.range [height, 0]
        
        if      xDomain[0] != _xDomain[0] or xDomain[1] != _xDomain[1]   or
                yDomain[0] != _yDomain[0] or yDomain[1] != _yDomain[1]   or
                width      != _width      or height     != _height
            @scales { @xScale, @yScale, @scaleLine }
        
        metrics
    
    
    # }}}
    
    
    
    /**
     * @constructor
     * @param {GraphView} graph
     * @param {GraphNodeData} model
     */
    (graph, model) ->
        @xScale = d3.time.scale().clamp(true)
        @yScale = d3.scale.log()
        @scaleLine = d3.svg.line()
            .x ([date, val], i) ~> @xScale date # TODO: assumes all metrics have the same x domain
            .y ([date, val], i) ~> @yScale val
            .interpolate 'linear'
        super ...
        @scales 
    
    
    watchOthers: ->
        @metrics()
    
    
    buildElement: (parentElement) ->
        @renderView parentElement
        @el el = $(parentElement).find('.canvas-node.graph-node').0
        el
    
    
    determineDOMParentForChildNode: (node) ->
        # SVG nodes
        if node.hasTrait Trait.SVG
            if node.hasTrait Trait.FG_LAYER
                @$ 'svg > g > g.fg' .0
            else if node.hasTrait Trait.BG_LAYER
                @$ 'svg > g > g.frame > g.bg' .0
            else
                @$ 'svg > g > g.frame > g.viewport' .0
        
        # HTML nodes
        else
            if node.hasTrait Trait.FG_LAYER
                @$ 'section.meta > .fg' .0
            else
                @$ 'section.meta > .bg' .0
        
    

