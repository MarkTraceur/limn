{EventEmitter} = require 'events'
Backbone = require 'backbone'

limn = exports

limn.{ _, op, event,
} =  { _, op, event, root,
} = limn.util = require './util'

# Decorate root limn namespace object with EventEmitter methods
emitter = limn.__emitter__ = new event.ReadyEmitter()
for k of <[ on addListener off removeListener emit trigger once removeAllListeners ]>
    limn[k] = emitter[k].bind emitter

limn.mount = (path) ->
    mnt = limn.config?.mount or '/'
    (if mnt is not '/' then mnt else '') + path


{ BaseView, BaseModel, BaseList,
} = limn.base       = require './base'
{ ChartType, DygraphsChartType, ChartElement, ChartElementData,
} = limn.chart      = require './chart'
{ Graph, GraphList, GraphDisplayView, GraphEditView, GraphListView,
} = limn.graph      = require './graph'
{ DashboardView, Dashboard,
} = limn.dashboard  = require './dashboard'
limn.data           = require './data'

/**
 * @class Sets up root application, automatically attaching to an existing element
 *  found at `appSelector` and delegating to the appropriate view.
 * @extends Backbone.Router
 */
LimnApp = limn.LimnApp = Backbone.Router.extend do # {{{
    appSelector : '#content .inner'
    
    routes:
        # 'graph-element'             : 'editElementGraph'
        'graphs/play-:graphId'      : 'playing'
        'graphs/(new|edit)'         : 'newGraph'
        'graphs/:graphId/edit'      : 'editGraph'
        'graphs/:graphId'           : 'showGraph'
        'graphs'                    : 'listGraphs'
        
        'dashboards/(new|edit)'     : 'newDashboard'
        'dashboards/:dashId/edit'   : 'editDashboard'
        'dashboards/:dashId'        : 'showDashboard'
        'dashboards'                : 'listDashboards'
    
    playing: (id) ->
        
        section = $ '<section></section>'
            .addClass 'play'
            .css 'max-width', '1000px'
            .css 'margin', '2em'
            .css 'position', 'relative'
        legend = $ '<fieldset></fieldset>'
            .addClass 'legend'
            .css 'width', '150px'
            .css 'margin', '0.5em'
            .css 'font-size', '1.2em'
            .css 'display', 'inline-block'
            .css 'vertical-align', 'top'
        legend.append $ '<legend>Legend</legend>'
        legend.append ($ '<ul></ul>'
            .css 'list-style-type', 'none'
            .css 'margin', '0'
        )
        section.append legend
        $ '#content div.inner' .append section
        els = '#content div.inner section.play'
        columnHeaders = ['Date','Total','English','French','Russian','German']
        columns = JSON.parse('[["2009-07-01T04:00:00.000Z","2009-08-01T04:00:00.000Z","2009-09-01T04:00:00.000Z","2009-10-01T04:00:00.000Z","2009-11-01T04:00:00.000Z","2009-12-01T05:00:00.000Z","2010-01-01T05:00:00.000Z","2010-02-01T05:00:00.000Z","2010-03-01T05:00:00.000Z","2010-04-01T04:00:00.000Z","2010-05-01T04:00:00.000Z","2010-06-01T04:00:00.000Z","2010-07-01T04:00:00.000Z","2010-08-01T04:00:00.000Z","2010-09-01T04:00:00.000Z","2010-10-01T04:00:00.000Z","2010-11-01T04:00:00.000Z","2010-12-01T05:00:00.000Z","2011-01-01T05:00:00.000Z","2011-02-01T05:00:00.000Z","2011-03-01T05:00:00.000Z","2011-04-01T04:00:00.000Z","2011-05-01T04:00:00.000Z","2011-06-01T04:00:00.000Z","2011-07-01T04:00:00.000Z","2011-08-01T04:00:00.000Z","2011-09-01T04:00:00.000Z","2011-10-01T04:00:00.000Z","2011-11-01T04:00:00.000Z","2011-12-01T05:00:00.000Z","2012-01-01T05:00:00.000Z","2012-02-01T05:00:00.000Z","2012-03-01T05:00:00.000Z","2012-04-01T04:00:00.000Z","2012-05-01T04:00:00.000Z","2012-06-01T04:00:00.000Z","2012-07-01T04:00:00.000Z"],[11219360,11181110,10887977,11043178,10639294,11128502,11733120,11305278,12047706,12026623,12183692,11805581,10629492,12248468,11818738,11480504,11098681,11508468,12723937,10974290,11763491,11550536,11457803,11633611,11832817,11229585,10895852,11331927,11114355,11647986,12383770,11460642,12033994,11612264,12674912,11286269,12568704],[3800326,3886201,3975209,3966889,3902243,4374903,3940400,3872091,4112800,4022522,4068360,3936495,3639586,3852380,3944768,4117648,3891872,3676690,4056182,3507974,3571127,3556524,3498850,3552013,3605263,3457975,3449623,3391328,3323552,3340036,3659243,3419351,3521599,3365389,3628181,3254213,3412014],[619129,678669,630692,668335,657055,658312,725472,680994,698237,690621,700854,657884,622563,654267,668774,664573,719598,750671,755076,666332,711916,688650,753054,738247,718636,730300,771663,743294,737252,788032,934061,877840,731409,716676,790461,749070,763027],[697713,738383,690338,722399,725696,724561,853931,757114,833921,751942,776209,724274,707918,783228,745009,744851,740709,740725,882368,759967,793626,723813,724012,732280,738646,713872,704692,737608,725358,740845,803885,739764,747559,728111,741101,707398,766656],[468191,476154,466919,518945,522467,503009,569919,550579,601440,569724,577053,570221,543494,566559,542575,567411,555158,597623,655625,613055,640432,562389,618313,573694,598377,585304,546246,554624,545079,552046,658113,636153,655107,597132,653075,588282,644717]]')
        
        lineData = columns.slice(1,columns.length)
        mergedLineData = d3.merge(lineData)
        dateDomain = columns[0].map (d) ->
            new Date(d)
        findDateIndex = (d) ->
            for dateInDomain, i of dateDomain
                if d.getMonth() == dateInDomain.getMonth() && d.getFullYear() == dateInDomain.getFullYear()
                    return i
            return undefined
        
        w = $ els .width() - 250
        h = 365
        margin = { top: 10, right: 10, bottom: 35, left: 60 }
        circleRadius = 6
        startX = d3.min(dateDomain)
        startY = d3.max(mergedLineData)
        stopX = d3.max(dateDomain)
        stopY = d3.min(mergedLineData)
        x = d3.time.scale().domain([d3.min(dateDomain), d3.max(dateDomain)]).range([0 + margin.left, w - margin.right]).clamp(true)
        y = d3.scale.log().domain([d3.max(mergedLineData), d3.min(mergedLineData)]).range([0 + margin.top, h - margin.bottom])
        colorScale = d3.scale.category20().domain(columnHeaders)
        numberFormats = [
            { ge: 1000000000000,    f: 'T' },
            { ge: 1000000000,       f: 'B' },
            { ge: 1000000,          f: 'M' },
            { ge: 1000,             f: 'K' },
        ]
        numberFormatter = (n) ->
            for format of numberFormats
                if n >= format.ge
                    trimmed = n/format.ge
                    trimmed = trimmed.toFixed(1) unless trimmed == Math.round(trimmed)
                    return trimmed + format.f
            return n
        dateFormatter = d3.time.format("%b, %Y")
        
        
        vis = d3.select(els)
            .append 'svg'
            .attr 'width', w
            .attr 'height', h
            .style 'display', 'inline-block'
        
        g = vis.append 'g'
        
        vis.on 'mouseout', (d, i) ->
            d3.select('line.verticalGuide')
                .attr 'x1', -1
                .attr 'x2', -1
        vis.on 'mousemove', (d, i) ->
            xOffset = d3.event.x - 195 # this is the trickiest magic number in the whole script TODO: replace with dynamic computation which will need to figure out the x offset of vis from its parent (which is where the d3.event.x is in reference to).  Needs to take into account a little slack on either side of each data point
            interpolatedDate = x.invert(xOffset)
            $ 'fieldset.legend legend', els .text(dateFormatter(interpolatedDate))
            d3.selectAll('span.legendItemValue')
                .text((d, i) ->
                    numberFormatter(
                        lineData[i][findDateIndex(interpolatedDate)]
                    )
                )
            guideLineOffset = if margin.left + circleRadius < xOffset && xOffset < w + margin.right then xOffset - 11 else -1
            d3.select('line.verticalGuide')
                .attr 'x1', guideLineOffset
                .attr 'x2', guideLineOffset
        
        guideLine = vis.append('line')
            .attr 'class', 'verticalGuide'
            .attr 'x1', -1
            .attr 'x2', -1
            .attr 'y1', 0
            .attr 'y2', h
            .style 'stroke', 'red'
            .style 'stroke-width', 1
        
        
        # common functions
        plotX = (d, i) -> x(dateDomain[i])
        plotY = (d, i) -> y(d)
        color = (d, i) -> colorScale(columnHeaders[i])
        lineGenerator = d3.svg.line()
            .x plotX
            .y plotY
            .interpolate 'linear'
        
        # TODO: the order things are appended matters.  Think on a generic solution here - grouping by g, d3.insert, and d3.sort might be the only choices
        # TODO: the number of ticks is ignored in log scales but required in linear scales - make sure this can be generic
        
        # horizontal grid lines
        yTicks = y.ticks(Math.floor((h - (margin.top + margin.bottom))/30)) # ignored in log scales, required in linear
        hGridLines = g.selectAll('line.horizontalGrid')
            .data(yTicks)
            .enter().append('line')
            .attr 'class', 'horizontalGrid'
            .attr 'x1', margin.left - circleRadius
            .attr 'y1', y
            .attr 'x2', w - margin.right + circleRadius
            .attr 'y2', y
            .style 'stroke', '#cacaca'
            .style 'stroke-width', 1
        
        # horizontal grid line labels
        # TODO: make this dependent on height and watch border cases
        yTicksLabels = d3.range(yTicks.length / 2).map((i) -> return yTicks[i * 2])
        hGridLineLabels = g.selectAll('text.horizontalGridLabel')
            .data(yTicksLabels)
            .enter().append('text')
            .attr 'class', 'horizontalGridLabel'
            .attr 'x', margin.left
            .attr 'dx', circleRadius * -2
            .attr 'y', y
            .attr 'dy', '.55em'
            .text numberFormatter
            .style 'text-anchor', 'end'
            .style 'font-size', '1.1em'
        
        # vertical grid line Labels
        xTicksLabels = x.ticks(d3.time.months, Math.floor(w / 187)) # TODO: the concept of months is hardcoded in this whole approach
        vGridLineLabels = g.selectAll('line.verticalGridLabel')
            .data(xTicksLabels)
            .enter().append('text')
            .attr 'class', 'verticalGridLabel'
            .attr 'x', x
            .attr 'y', h + circleRadius
            .attr 'dy', circleRadius * -1
            .text dateFormatter
            .style 'text-anchor', 'middle'
            .style 'font-size', '1.1em'
        
        # axes
        g.append('line')
            .attr 'class', 'xAxis'
            .attr 'x1', 0 + margin.left - circleRadius
            .attr 'x2', w
            .attr 'y1', y(stopY) + margin.top
            .attr 'y2', y(stopY) + margin.top
            .style 'stroke', '#cacaca'
            .style 'stroke-width', 3
        g.append('line')
            .attr 'class', 'yAxis'
            .attr 'x1', 0 + margin.left - circleRadius
            .attr 'x2', 0 + margin.left - circleRadius
            .attr 'y1', y(startY)
            .attr 'y2', y(stopY) + margin.top
            .style 'stroke', '#cacaca'
            .style 'stroke-width', 3
        
        # a polyline for each metric
        metricLines = g.selectAll('path')
            .data(lineData)
            .enter().append('path')
            .attr 'd', lineGenerator
            .style 'fill', 'none'
            .style 'stroke', color
            .style 'stroke-width', 5
        
        # circles at data points on lines
        circleGroups = g.selectAll('g.circleGroup')
            .data(lineData)
            .enter().append('g')
            .attr 'class', 'circleGroup'
            .style 'fill', color
        
        circleGroups.selectAll('circle')
            .data((d) -> d)
            .enter().append('circle')
            .attr 'cx', plotX
            .attr 'cy', plotY
            .attr 'r', circleRadius
        
        # legend
        legendItem = d3.select(els + ' fieldset.legend ul').selectAll('li')
            .data(lineData)
            .enter().append('li')
            .style 'display', 'table-row'
        
        legendItem.append('span')
            .text((d, i) -> columnHeaders[i+1])
            .style 'color', color
            .style 'display', 'table-cell'
            .style 'width', '120px'
        
        legendItem.append('span')
            .attr 'class', 'legendItemValue'
            .style 'display', 'table-cell'
            .style 'text-align', 'right'
    
    
    
    /**
     * @constructor
     */
    constructor: function LimnApp (@config={})
        @appSelector = that if config.appSelector
        @el  = config.el or= jQuery @appSelector .0
        @$el = jQuery @el
        Backbone.Router.call this, config
        this
    
    initialize: ->
        jQuery ~> @setup()
        this
    
    setup: ->
        # Add / route for Homepage
        @route /^(?:[\?].*)?$/, 'home'
        # Start observing history changes
        Backbone.history.start { +pushState, root:@config.mount }
    
    # Helper for setting up models
    processData: (id, data={}) ->
        ### If we got querystring args, apply them as overrides to the data
        # loc = String root.location
        # if loc.split '?' .1
        #     data = _.uncollapseObject _.fromKV that.replace('#', '%23')
        #     data.parents = JSON.parse that if data.parents
        #     data.options = _.synthesize do
        #         data.options or {}
        #         (v, k) -> [ k, dyglib.parseOption(k,v) ]
        unless id and _ <[ edit new ]> .contains id
            data.id = data.slug = id
        data
    
    
    
    /* * * *  Routes  * * * */
    
    
    home: ->
        # console.log "#this.home!"
        @showDashboard 'reportcard'
    
    
    ### Graphs
    
    createGraphModel: (id) ->
        data = @processData id
        graph = new Graph data, {+parse}
    
    newGraph: ->
        @editGraph()
    
    editGraph: (id) ->
        @model = @createGraphModel id
        @view = new GraphEditView {@model} .attach @el
    
    showGraph: (id) ->
        return @editGraph id if _ <[ new edit ]> .contains id
        @model = @createGraphModel id
        @view  = new GraphDisplayView {@model} .attach @el
    
    listGraphs: ->
        @collection = new GraphList()
        @view = new GraphListView {@collection} .attach @el
    
    
    ### Dashboards
    
    createDashboardModel: (id) ->
        data = @processData id
        dashboard = new Dashboard data, {+parse}
    
    newDashboard: ->
        console.error 'newDashboard!?'
    
    editDashboard: (id) ->
        console.error 'editDashboard!?'
    
    showDashboard: (id) ->
        return @editDashboard id if _ <[ new edit ]> .contains id
        @model = @createDashboardModel id
        @view  = new DashboardView {@model} .attach @el
        @model.once 'ready', @updateDashboardTitle, this
    
    listDashboards: ->
        console.error 'listDashboards!?'
    
    updateDashboardTitle: ->
        return this unless dashName = @model.getName()
        root.document?.title = dashName
        if sub = @model.get 'subhead'
            head = @model.get 'headline'
            @$ '.page-header h1' .html "#head <small>#sub</small>"
        this
    
    
    ### Misc
    
    $: -> @$el.find.apply @$el, arguments
    
    getClassName: ->
        "#{@..name or @..displayName}"
    
    toString: ->
        "#{@getClassName()}()"
# }}}


### Static Methods
LimnApp import do
    
    findConfig : ->
        # TODO: fill out inferred config
        config = root.limn_config or {}
        config.mount or= "/"
        config
    
    main : function limnMain
        config = limn.config or= LimnApp.findConfig()
        limn.app or= new LimnApp config unless config.libOnly
        limn.emit 'main', limn.app


jQuery LimnApp.main
