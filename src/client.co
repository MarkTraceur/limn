{EventEmitter} = require 'events'
Backbone = require 'backbone'

limn = exports

limn.{ _, op, event,
} =  { _, op, event, root,
} = limn.util = require './util'

# Decorate root limn namespace object with EventEmitter methods
emitter = limn.__emitter__ = new event.ReadyEmitter()
for k of <[ on addListener off removeListener emit trigger once removeAllListeners ]>
    limn[k] = emitter[k].bind emitter

limn.mount = (path) ->
    mnt = limn.config?.mount or '/'
    (if mnt is not '/' then mnt else '') + path


{ BaseView, BaseModel, BaseList,
} = limn.base       = require './base'
{ ChartType, DygraphsChartType, ChartElement, ChartElementData,
} = limn.chart      = require './chart'
{ Graph, GraphList, GraphDisplayView, GraphEditView, GraphListView,
} = limn.graph      = require './graph'
{ DashboardView, Dashboard,
} = limn.dashboard  = require './dashboard'
limn.data           = require './data'

/**
 * @class Sets up root application, automatically attaching to an existing element
 *  found at `appSelector` and delegating to the appropriate view.
 * @extends Backbone.Router
 */
LimnApp = limn.LimnApp = Backbone.Router.extend do # {{{
    appSelector : '#content .inner'
    
    routes:
        # 'graph-element'             : 'editElementGraph'
        'graphs/play-:graphId'      : 'playing'
        'graphs/(new|edit)'         : 'newGraph'
        'graphs/:graphId/edit'      : 'editGraph'
        'graphs/:graphId'           : 'showGraph'
        'graphs'                    : 'listGraphs'
        
        'dashboards/(new|edit)'     : 'newDashboard'
        'dashboards/:dashId/edit'   : 'editDashboard'
        'dashboards/:dashId'        : 'showDashboard'
        'dashboards'                : 'listDashboards'
    
    playing: (id) ->
        
        columnHeaders = ['Date','Total','English','French','Russian','German']
        columns = JSON.parse('[["2009-07-01T04:00:00.000Z","2009-08-01T04:00:00.000Z","2009-09-01T04:00:00.000Z","2009-10-01T04:00:00.000Z","2009-11-01T04:00:00.000Z","2009-12-01T05:00:00.000Z","2010-01-01T05:00:00.000Z","2010-02-01T05:00:00.000Z","2010-03-01T05:00:00.000Z","2010-04-01T04:00:00.000Z","2010-05-01T04:00:00.000Z","2010-06-01T04:00:00.000Z","2010-07-01T04:00:00.000Z","2010-08-01T04:00:00.000Z","2010-09-01T04:00:00.000Z","2010-10-01T04:00:00.000Z","2010-11-01T04:00:00.000Z","2010-12-01T05:00:00.000Z","2011-01-01T05:00:00.000Z","2011-02-01T05:00:00.000Z","2011-03-01T05:00:00.000Z","2011-04-01T04:00:00.000Z","2011-05-01T04:00:00.000Z","2011-06-01T04:00:00.000Z","2011-07-01T04:00:00.000Z","2011-08-01T04:00:00.000Z","2011-09-01T04:00:00.000Z","2011-10-01T04:00:00.000Z","2011-11-01T04:00:00.000Z","2011-12-01T05:00:00.000Z","2012-01-01T05:00:00.000Z","2012-02-01T05:00:00.000Z","2012-03-01T05:00:00.000Z","2012-04-01T04:00:00.000Z","2012-05-01T04:00:00.000Z","2012-06-01T04:00:00.000Z","2012-07-01T04:00:00.000Z"],[11219360,11181110,10887977,11043178,10639294,11128502,11733120,11305278,12047706,12026623,12183692,11805581,10629492,12248468,11818738,11480504,11098681,11508468,12723937,10974290,11763491,11550536,11457803,11633611,11832817,11229585,10895852,11331927,11114355,11647986,12383770,11460642,12033994,11612264,12674912,11286269,12568704],[3800326,3886201,3975209,3966889,3902243,4374903,3940400,3872091,4112800,4022522,4068360,3936495,3639586,3852380,3944768,4117648,3891872,3676690,4056182,3507974,3571127,3556524,3498850,3552013,3605263,3457975,3449623,3391328,3323552,3340036,3659243,3419351,3521599,3365389,3628181,3254213,3412014],[619129,678669,630692,668335,657055,658312,725472,680994,698237,690621,700854,657884,622563,654267,668774,664573,719598,750671,755076,666332,711916,688650,753054,738247,718636,730300,771663,743294,737252,788032,934061,877840,731409,716676,790461,749070,763027],[697713,738383,690338,722399,725696,724561,853931,757114,833921,751942,776209,724274,707918,783228,745009,744851,740709,740725,882368,759967,793626,723813,724012,732280,738646,713872,704692,737608,725358,740845,803885,739764,747559,728111,741101,707398,766656],[468191,476154,466919,518945,522467,503009,569919,550579,601440,569724,577053,570221,543494,566559,542575,567411,555158,597623,655625,613055,640432,562389,618313,573694,598377,585304,546246,554624,545079,552046,658113,636153,655107,597132,653075,588282,644717]]')
        
        $ '#content div.inner' .append $('
            <section class="play">
                <fieldset class="legend">
                    <legend>Legend</legend>
                    <ul></ul>
                </fieldset>
                <div class="viewport"></div>
            </section>
        ');
        els = '#content div.inner section.play'
        legendTitle = $ 'fieldset.legend legend', els
        viewport = $ 'div.viewport', els
        
        # style to be factored out into css
        $('<style>
            section.play { max-width: 1000px; margin: 2em; position: relative; }
            div.viewport { width: 750px; height: 365px; display: inline-block }
            fieldset.legend { width: 150px; margin: 0.5em; font-size: 1.2em; display: inline-block; vertical-align: top; }
            fieldset.legend ul { list-style-type: none; margin: 0 }
            fieldset.legend li { display: table-row; }
            fieldset.legend li span { display: table-cell; }
            fieldset.legend li span.legendItemText { width: 120px; }
            fieldset.legend li span.legendItemValue { text-align: right; }
            
            g.brush { stroke: #fff; fill-opacity: .125; shape-rendering: crispEdges; }
            line.verticalGuide { stroke: red; stroke-width: 1; }
            
            g.horizontalGrid line { stroke: #cacaca; stroke-width: 1; }
            g.verticalGrid line { stroke: #cacaca; stroke-width: 1; }
            
            g.axis path { stroke: #cacaca; stroke-width: 3; }
            g.axis text { font-size: 1.1em; stroke: #666; stroke-width: 1; }
            g.metricVisualizations path { fill: none; stroke-width: 5; }
        </style>').appendTo('head')
        
        # general setup - independent of data
        numberFormats = [
            { ge: 1000000000000,    f: 'T' },
            { ge: 1000000000,       f: 'B' },
            { ge: 1000000,          f: 'M' },
            { ge: 1000,             f: 'K' },
        ]
        numberFormatter = (n) ->
            for format of numberFormats
                if n >= format.ge
                    trimmed = n/format.ge
                    trimmed = trimmed.toFixed(1) unless trimmed == Math.round(trimmed)
                    return trimmed + format.f
            return n
        dateFormatter = d3.time.format("%b %Y")
        selectionIsTooSmall = (d1, d2) ->
            return graphData.x(d2) - graphData.x(d1) <= graphData.dx
        findDateIndex = (d) ->
            for date, i of graphData.dateDomain
                return i unless not selectionIsTooSmall(d, date)
            return undefined
        
        # helper function - might not be needed
        unscale = (el) ->
            svg = el.ownersvgelement
            xf = el.scaleindependentxform
            unless xf
                xf = el.scaleindependentxform = svg.createsvgtransform()
                el.transform.baseval.appenditem xf
            m = svg.gettransformtoelement el.parentnode
            m.e = m.f = 0
            xf.setMatrix m
        
        w = -> viewport.width()
        h = -> viewport.height()
        circleRadius = 6
        circleBoxRadius = circleRadius + 1
        colorScale = d3.scale.category20().domain(columnHeaders)
        
        # data setup
        layout = {
            h: h(),
            w:  w(),
            top:    { x: 0,     y: 0,       h: 30,      w: null },
            bottom: { x: 0,     y: null,    h: 30,      w: null },
            left:   { x: 0,     y: null,    h: null,    w: 60   },
            right:  { x: null,  y: null,    h: null,    w: 60   },
            middle: { x: null,  y: null,    h: null,    w: null }
        }
        graphData = {}
        
        setupGraphData = (startDate, endDate) ->
            # set up and calculate the layout (breaking down to steps in case the calculation itself is useful)
            layout.w = w()
            layout.h = h()
            layout.top.w = layout.bottom.w = layout.w
            layout.middle.w = layout.w - (layout.left.w + layout.right.w)
            layout.left.h = layout.right.h = layout.middle.h = layout.h - (layout.top.h + layout.bottom.h)
            
            layout.bottom.y = layout.h - layout.bottom.h
            layout.left.y = layout.right.y = layout.middle.y = layout.top.h
            layout.right.x = layout.w - layout.right.w
            layout.middle.x = layout.left.w
            layout.middle.y = layout.top.h
            
            # set up graph data
            graphData.lineData = columns.slice(1,columns.length)
            graphData.dateDomain = columns[0].map (d) -> new Date(d)
            graphData.minDate = d3.min(graphData.dateDomain)
            graphData.maxDate = d3.max(graphData.dateDomain)
            graphData.zoomFactorX = 1
            graphData.zoomStartX = 0
            
            startDate ?= graphData.minDate
            endDate ?= graphData.maxDate
            
            # find what to slice out of the old data
            indices = []
            for date, i of graphData.dateDomain
                if startDate <= date && date <= endDate
                    indices.push i
            return false if indices.length is 0
            # slice
            startSlice = indices[0]
            sliceEnd = indices[indices.length-1] + 1
            for line, i of graphData.lineData
                graphData.lineData[i] = line.slice(startSlice, sliceEnd)
            graphData.dateDomain = graphData.dateDomain.slice(startSlice, sliceEnd)
            
            mergedLineData = d3.merge(graphData.lineData)
            startY = d3.max(mergedLineData)
            stopY = d3.min(mergedLineData)
            yPadding = (startY - stopY)
            startY += yPadding / 10 # TODO: make these fudge factors dynamic
            stopY -= yPadding / 500 # TODO: make these fudge factors dynamic
            graphData.x = d3.time.scale().domain([startDate, endDate]).range([0, layout.middle.w]).clamp(true)
            graphData.y = d3.scale.log().domain([startY, stopY]).range([0, layout.middle.h])
            graphData.dx = (graphData.x(graphData.maxDate) - graphData.x(graphData.minDate)) / (graphData.dateDomain.length - 1)
            return true
        
        # svg specific methods
        moveLine = (l, toX) ->
            l
                .attr 'x1', toX
                .attr 'x2', toX
        
        # start drawing
        redraw = ->
            viewport.html('')
            
            vis = d3.select('div.viewport').append 'svg'
                .attr 'width', layout.w
                .attr 'height', layout.h
                .attr 'pointer-events', 'all'
            
            # elements used throughout
            defs = vis.append 'defs'
            defs.append 'clipPath'
                .attr 'id', 'clipMetricVisualizations' # TODO: can't reuse this because of hard coded id
                .append 'rect'
                    .attr 'width', layout.middle.w
                    .attr 'height', layout.middle.h
            # placeholder for defs used by metrics
            metricDefs = defs.append 'g'
                .classed 'metricDefs', true
            
            # middle first so it can hide if its pieces are transformed
            middle = vis.append 'g'
                .classed 'middle', true
                .attr 'width', layout.middle.w
                .attr 'height', layout.middle.h
                .attr 'transform', "translate(#{layout.middle.x}, #{layout.middle.y})"
            
            top = vis.append 'g'
                .classed 'top', true
                .attr 'width', layout.top.w
                .attr 'height', layout.top.h
                .attr 'transform', "translate(#{layout.top.x}, #{layout.top.y})"
            
            bottom = vis.append 'g'
                .classed 'bottom', true
                .attr 'width', layout.bottom.w
                .attr 'height', layout.bottom.h
                .attr 'transform', "translate(#{layout.bottom.x}, #{layout.bottom.y})"
            
            left = vis.append 'g'
                .classed 'left', true
                .attr 'width', layout.left.w
                .attr 'height', layout.left.h
                .attr 'transform', "translate(#{layout.left.x}, #{layout.left.y})"
            
            right = vis.append 'g'
                .classed 'right', true
                .attr 'width', layout.right.w
                .attr 'height', layout.right.h
                .attr 'transform', "translate(#{layout.right.x}, #{layout.right.y})"
            
            zoomBrush = d3.svg.brush().x(graphData.x)
                .on 'brushend', ->
                    e = d3.event.target.extent()
                    unless selectionIsTooSmall(e[0], e[1])
                        graphData.zoomStartX = graphData.x(e[0])
                        translateX = -1 * graphData.zoomStartX
                        stopX = graphData.x(e[1])
                        
                        #graphData.x.domain([e[0], e[1]])
                        
                        graphData.zoomFactorX = layout.middle.w / (stopX - graphData.zoomStartX)
                        undoScale = 1 / graphData.zoomFactorX
                        middle.selectAll('g.metricVisualizations,g.verticalGrid').transition()
                            .attr('transform', "scale(#{graphData.zoomFactorX},1) translate(#{translateX}, 0)")
                        metricDefs.selectAll('circle').transition()
                            .attr 'transform', ->
                                # the circle ends up translated but not scaled after we apply undoScale
                                #   to correct this, we first observe where the circle is and where we want it:
                                #   actual x coordinate: cx - zoomStartX
                                #   desire x coordinate: cx * zoomFactorX - zoomStartX
                                #   dx: (desired - actual) / zoomFactorX    # divide by zoomFactorX to adjust for the new scale
                                cx = d3.select(@).attr 'cx'
                                dx = cx * (graphData.zoomFactorX - 1) / graphData.zoomFactorX
                                "matrix(#undoScale 0 0 1 #dx 0)"
                    
                    zoomBrush.clear()
                    zoomBrushContainer.call(zoomBrush)
                    $(zoomBrushContainer).toggle(false)
            
            zoomBrushContainer = middle.append 'g'
                .classed 'brush', true
                .call(zoomBrush)
            zoomBrushContainer.selectAll('rect')
                .attr 'height', layout.middle.h
            
            vis.on 'mouseout', (d, i) ->
                moveLine(guideLine, -10000)
            vis.on 'mousemove', (d, i) ->
                trackGuideLine.apply this, [d, i]
            vis.on 'dblclick', (d, i) ->
                graphData.zoomFactorX = 1
                graphData.zoomStartX = 0
                middle.selectAll('g.metricVisualizations,g.verticalGrid').transition()
                    .attr('transform', '')
                metricDefs.selectAll('circle').transition()
                        .attr('transform', '')
                $(zoomBrushContainer).toggle(true)
                
                # clear any selections caused by this double click
                window.getSelection?().removeAllRanges()
                document.selection?.empty();
                true
            
            trackGuideLine = (d, i) ->
                xOffset = d3.mouse($('g.middle', viewport)[0])[0] # TODO: find out why middle can't be passed in here directly
                xOffset /= graphData.zoomFactorX
                trackGuideLineDateOffset = (graphData.dx / 2)
                interpolatedDate = graphData.x.invert(xOffset + trackGuideLineDateOffset + graphData.zoomStartX)
                
                legendTitle.text(dateFormatter(interpolatedDate))
                
                d3.selectAll('span.legendItemValue')
                    .text((d, i) ->
                        numberFormatter(
                            graphData.lineData[i][findDateIndex(interpolatedDate)]
                        )
                    )
                
                guideLineOffset = if 0 < xOffset && xOffset < layout.middle.w then xOffset else -1
                moveLine(guideLine, guideLineOffset * graphData.zoomFactorX)
            
            # common functions
            plotX = (d, i) -> graphData.x(graphData.dateDomain[i])
            plotY = (d, i) -> graphData.y(d)
            color = (d, i) -> colorScale(columnHeaders[i])
            lineGenerator = d3.svg.line()
                .x plotX
                .y plotY
                .interpolate 'linear'
            
            yTicks = graphData.y.ticks(Math.floor(layout.middle.h/30)) # TODO: ticks parameter ignored in log scales, required in linear
            
            xTicks = graphData.x.ticks(d3.time.months, Math.floor(layout.middle.width / 187)) # TODO: the concept of months is hardcoded in this whole approach
            
            # axes
            yTicksLabels = d3.range(yTicks.length / 2).map((i) -> return yTicks[i * 2]) # TODO: make different ticks logic for each type of quantitative scale
            xAxis = d3.svg.axis().scale(graphData.x).ticks(d3.time.months, 4).orient('bottom').tickFormat(dateFormatter) # TODO: don't hardcode this
            yAxis = d3.svg.axis().scale(graphData.y).tickValues(yTicksLabels).orient('left').tickFormat(numberFormatter)
            middle.append 'g'
                .classed 'axis', true
                .attr 'transform', "translate(0, #{layout.middle.h})"
                .call xAxis
            middle.append 'g'
                .classed 'axis', true
                .call yAxis
            
            # a group for each metric
            dataViewport = middle.append 'g'
                .classed 'dataViewport', true
                .attr 'clip-path', 'url(#clipMetricVisualizations)'
            
            # horizontal grid lines
            dataViewport.append 'g'
                .classed 'horizontalGrid', true
                .selectAll 'line'
                    .data yTicks
                    .enter().append 'line'
                        .attr 'x1', 0
                        .attr 'y1', graphData.y
                        .attr 'x2', layout.middle.w
                        .attr 'y2', graphData.y
            
            # vertical grid line Labels
            dataViewport.append 'g'
                .classed 'verticalGrid', true
                .selectAll 'line'
                    .data xTicks
                    .enter().append 'line'
                        .attr 'vector-effect': 'non-scaling-stroke'
                        .attr 'x1', graphData.x
                        .attr 'y1', 0
                        .attr 'x2', graphData.x
                        .attr 'y2', layout.middle.h
            
            metricVisualizations = dataViewport.append 'g'
                .classed 'metricVisualizations', true
                .selectAll 'g'
                    .data graphData.lineData
                    .enter().append 'g'
            
            # create a marker for each metric to display circles along the line
            $('g.metricDefs marker').remove()
            metricDefs.selectAll 'marker'
                .data graphData.lineData
                .enter().append 'marker'
                    .attr 'id', (d, i) -> "metricPathDot#i" # TODO: can't reuse because of hard-coded ids
                    .attr 'markerUnits', 'userSpaceOnUse'
                    .attr 'markerWidth', circleBoxRadius * 2
                    .attr 'markerHeight', circleBoxRadius * 2
                    .attr 'refX', circleBoxRadius
                    .attr 'refY', circleBoxRadius
                    .append 'circle'
                        .attr 'r', circleRadius
                        .attr 'cx', circleBoxRadius
                        .attr 'cy', circleBoxRadius
                        .attr 'fill', color
                        .attr 'stroke', color
            
            # a polyline for each metric
            metricVisualizations.append 'path'
                .attr 'd', lineGenerator
                .style 'stroke', color
                .attr 'vector-effect', 'non-scaling-stroke'
                .attr 'marker-start', (d, i) -> "url(\#metricPathDot#i)"
                .attr 'marker-mid', (d, i) -> "url(\#metricPathDot#i)"
                .attr 'marker-end', (d, i) -> "url(\#metricPathDot#i)"
            
            # legend
            legendItem = d3.select(els + ' fieldset.legend ul').selectAll('li')
                .data(graphData.lineData)
                .enter().append('li')
            
            legendItem.append('span')
                .text((d, i) -> columnHeaders[i+1])
                .classed 'legendItemText', true
                .style 'color', color
            
            legendItem.append('span')
                .classed 'legendItemValue', true
            
            # guide line needs to go on top of everything
            guideLine = dataViewport.append('line')
                .classed 'verticalGuide', true
                .attr 'pointer-events', 'none'
                .attr 'y1', layout.middle.h
                .attr 'y2', 0
            
            moveLine(guideLine, -1)
        
        setupGraphData()
        redraw()
        
    
    /**
     * @constructor
     */
    constructor: function LimnApp (@config={})
        @appSelector = that if config.appSelector
        @el  = config.el or= jQuery @appSelector .0
        @$el = jQuery @el
        Backbone.Router.call this, config
        this
    
    initialize: ->
        jQuery ~> @setup()
        this
    
    setup: ->
        # Add / route for Homepage
        @route /^(?:[\?].*)?$/, 'home'
        # Start observing history changes
        Backbone.history.start { +pushState, root:@config.mount }
    
    # Helper for setting up models
    processData: (id, data={}) ->
        ### If we got querystring args, apply them as overrides to the data
        # loc = String root.location
        # if loc.split '?' .1
        #     data = _.uncollapseObject _.fromKV that.replace('#', '%23')
        #     data.parents = JSON.parse that if data.parents
        #     data.options = _.synthesize do
        #         data.options or {}
        #         (v, k) -> [ k, dyglib.parseOption(k,v) ]
        unless id and _ <[ edit new ]> .contains id
            data.id = data.slug = id
        data
    
    
    
    /* * * *  Routes  * * * */
    
    
    home: ->
        # console.log "#this.home!"
        @showDashboard 'reportcard'
    
    
    ### Graphs
    
    createGraphModel: (id) ->
        data = @processData id
        graph = new Graph data, {+parse}
    
    newGraph: ->
        @editGraph()
    
    editGraph: (id) ->
        @model = @createGraphModel id
        @view = new GraphEditView {@model} .attach @el
    
    showGraph: (id) ->
        return @editGraph id if _ <[ new edit ]> .contains id
        @model = @createGraphModel id
        @view  = new GraphDisplayView {@model} .attach @el
    
    listGraphs: ->
        @collection = new GraphList()
        @view = new GraphListView {@collection} .attach @el
    
    
    ### Dashboards
    
    createDashboardModel: (id) ->
        data = @processData id
        dashboard = new Dashboard data, {+parse}
    
    newDashboard: ->
        console.error 'newDashboard!?'
    
    editDashboard: (id) ->
        console.error 'editDashboard!?'
    
    showDashboard: (id) ->
        return @editDashboard id if _ <[ new edit ]> .contains id
        @model = @createDashboardModel id
        @view  = new DashboardView {@model} .attach @el
        @model.once 'ready', @updateDashboardTitle, this
    
    listDashboards: ->
        console.error 'listDashboards!?'
    
    updateDashboardTitle: ->
        return this unless dashName = @model.getName()
        root.document?.title = dashName
        if sub = @model.get 'subhead'
            head = @model.get 'headline'
            @$ '.page-header h1' .html "#head <small>#sub</small>"
        this
    
    
    ### Misc
    
    $: -> @$el.find.apply @$el, arguments
    
    getClassName: ->
        "#{@..name or @..displayName}"
    
    toString: ->
        "#{@getClassName()}()"
# }}}


### Static Methods
LimnApp import do
    
    findConfig : ->
        # TODO: fill out inferred config
        config = root.limn_config or {}
        config.mount or= "/"
        config
    
    main : function limnMain
        config = limn.config or= LimnApp.findConfig()
        limn.app or= new LimnApp config unless config.libOnly
        limn.emit 'main', limn.app


jQuery LimnApp.main
