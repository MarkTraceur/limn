ko     = require 'knockout'
unwrap = ko.utils.unwrapObservable

{ EventEmitter, ReadyEmitter,
} = require 'emitters'

{ _, op, root, generateId, guidFor,
} = require '../util'



/**
 * @class Root-class for all Models.
 * @extends EventEmitter
 */
class exports.Model extends EventEmitter
    
    /**
     * Unique identifier for this object. Uniqueness is only guaranteed for this
     * pageload session; this value is safe to use in circumstances requiring numeric identity
     * (such as calculating a hashkey for a Map, or for DOM id attributes) but not when
     * global uniqueness is required.
     * 
     * @protected
     * @type String
     */
    __id__ : null
    
    /**
     * Attribute data of the model. Individual properties are also aliased 
     * onto the model object itself if no property already exists.
     * 
     * @protected
     * @type Map<Key, ko.observable>
     */
    attributes : null
    
    /**
     * Maps attribute keys to sub-models.
     * 
     * @protected
     * @type Map<Key, ModelClass>
     */
    attributeTypes : null
    
    
    
    /**
     * @constructor
     */
    (attributes={}) ->
        @__id__            = generateId()
        @attributes        = {}
        @attributeTypes  or= {}
        
        # Build and type attribute observers.
        @_setupAttributes attributes, @attributeTypes
        
        # Build non-attribute observables and computed property instances.
        @_setupObservables()
        
        this
    
    
    
    /**
     * Gets the value of the id attribute for this model.
     * @returns {String} Instance's id.
     */
    getId: ->
        @__id__
    
    
    /**
     * Invoked to acquire default attribute values.
     * 
     * Note that *all* known attributes of the Model should be included -- even
     * if simply as `null` keys (even the `id` attribute, if the model has a concept
     * of server-side global uniqueness!) -- so we can create the observables
     * fields.
     * 
     * @returns {Object} Hash of default attribute values.
     */
    defaults: ->
        {}
    
    
    /**
     * Invoked to transform raw attribute data into its "proper" form for
     * this model, whatever that might be.
     * 
     * @param {Object} data Raw attributes to canonicalize.
     * @returns {Object} Converted raw data.
     */
    canonicalize: (data) ->
        data
    
    
    
    /* * * *  Knockout-Aware Accessors  * * * {{{ */
    
    
    /**
     * Gets the attribute value at `key`.
     * 
     * @param {String} key Key to get.
     * @returns {*} Value at `key`.
     */
    get: (key) ->
        unwrap @attributes?[key]
    
    
    /**
     * Gets the attribute value at `key`, circumventing dependency tracking.
     * 
     * @param {String} key Key to peek.
     * @returns {*} Value at `key`.
     */
    peek: (key) ->
        if ko.isObservable val = @attributes?[key]
            val.peek()
        else
            val
    
    
    /**
     * Puts a single attribute value to `key`.
     * 
     * @protected
     * @param {String} key Key to set.
     * @param {*} val Value to set at `key`.
     * @returns {this}
     */
    _set: (key, val) ->
        return this unless key?
        throw new Error "Attributes hash does not exist!" unless @attributes?
        unless ko.isObservable obs = @attributes[key]
            obs = @attributes[key] = @_generateAttribute val, @attributeTypes[key]
            @[key] ?= obs
        else
            obs val
        this
    
    
    /**
     * Sets attribute values, taking either a single (key, value)-pair, or
     * a map of them.
     * 
     * @param {String|Object} key The key to set. If an object is supplied here,
     *  each key will be set with its value on the target object.
     * @param {*} [value] Value to set at `key`. Omit this if an object of
     *  KV-pairs was passed as `key`.
     * @returns {this}
     */
    set: (key, val) ->
        return this unless key?
        if key and _.isObject(key)
            values = key
        else
            values = { "#key": val }
        for key, value in values
            @_set key, value
        this
    
    
    /**
     * Sets the attribute value at `key` to `undefined`.
     * 
     * @param {String} key Key to unset.
     * @returns {this}
     */
    unset: (key) ->
        @_set key, undefined
    
    
    /**
     * Sets the attribute value at `key` to `undefined`, and then removes
     * the observable from both the attributes hash and the instance (if attached).
     * 
     * @param {String} key Key to remove.
     * @returns {this}
     */
    remove: (key) ->
        return this unless key?
        throw new Error "Attributes hash does not exist!" unless @attributes?
        
        if ko.isObservable obs = @attributes[key]
            obs undefined
            obs.dispose?()
            delete @[key] if obs is @[key]
        
        delete @attributes[key]
        this
    
    
    /**
     * Updates model with new data such that it will only contain keys
     * found in the new attributes (and existing attributes will be unset).
     * 
     * @param {Object} values Key-value pairs to update.
     * @returns {this}
     */
    update: (values) ->
        throw new Error "Attributes hash does not exist!" unless @attributes?
        
        # Update the given attributes
        @set values
        
        # Then remove all missing keys
        for k of _.keys(@attributes)
            continue if k in values
            @remove k
        
        this
    
    
    /**
     * Delete all attributes from the model.
     * @returns {this}
     */
    clear: ->
        @update {}
    
    
    /**
     * Clone this model.
     * @returns {Model} A new instance of this model, bearing the same attributes.
     */
    clone: ->
        # TODO: @attributes might contain objects or models that need recursive cloning?
        json = @toJS @attributes
        ModelClass = @constructor
        new ModelClass json
    
    
    # }}}
    /* * * *  Serialization  * * * {{{ */
    
    
    /**
     * Recursively unwrap any observables in the given attributes hash.
     * Called by `toJSON()`.
     * 
     * @returns {Object} A plain JS object, suitable for serialization.
     */
    toJS: (attributes=@attributes) ->
        # console.log "#{this}.toJS()", arguments
        _.reduce do
            attributes
            (json, obs, key) ~>
                val = if ko.isObservable obs then obs.peek() else obs
                if typeof val?.toJS is 'function'
                    val = val.toJS() ? val
                else if typeof val?.toJSON is 'function'
                    val = val.toJSON() ? val
                else if _.isPlainObject val
                    val = @toJS val
                json[key] = val if val?
                json
            {}
    
    
    toJSON: ->
        @toJS @attributes
    
    
    
    # }}}
    /* * * *  Helpers  * * * {{{ */
    
    
    /**
     * Build observables and computed property instances.
     * @protected
     * @param {Object} [target=this] Target object for processed properties.
     * @param {Object} [source=this] Source object to process.
     * @returns {Object} Target object.
     */
    _setupObservables: (target=this, source=this) ->
        for name, fn in source
            # We only care about functions
            continue unless typeof fn is 'function'
            
            # Preserve attribute-observers
            continue if fn is @attributes[name]
            
            # Build observables/computed properties
            target[name] = @_setupObservable fn, name, target
        target
    
    
    /**
     * Build observable or computed property instance for a
     * given (methodName, method) pair.
     * 
     * @protected
     * @param {*} method Value at `name`.
     * @param {String} methodName Property name.
     * @param {Object} [owner=this] Owner-object for `ko.computed`.
     * @returns {*} New property value.
     */
    _setupObservable: (fn, name, owner=this) ->
        return fn unless typeof fn is 'function'
        
        # Preserve attribute-observers
        return fn if fn is @attributes[name]
        
        read = fn
        # Annotated to become a computed observer
        if fn.__computed__
            options = { read, owner } import fn.__computed_options__
            return ko.computed(options)
            
        # Annotated to become an async computed observer
        else if fn.__async_computed__
            options = { read, owner } import fn.__async_computed_options__
            return ko.computed(options).async({} import options)
            
        # Re-wrap non-attribute observables and copy objects so neither causes shared state
        else if ko.isObservable fn
            val = fn.peek()
            if typeof val?.clone is 'function'
                val = val.clone()
            else if _.isArray val
                val .= slice()
            else if _.isObject val
                val = _.merge {}, val
            return ko.utils.makeObservable val
        
        fn
    
    
    _setupAttributes: (attributes, attrTypes=@attributeTypes) ->
        attributes  = @canonicalize _.merge @defaults(), attributes
        @attributes = @_generateAttributes attributes, attrTypes
        _.defaults this, @attributes
        @attributes
    
    /**
     * Wraps the properties found in the `attributes` map with observables,
     * applying types as specified in `attrTypes`.
     * 
     * @protected
     * @param {Map} data Hash of nascent attributes.
     * @param {Map<Key, ModelClass>} [attrTypes={}] Model type to ensure.
     * @param {Object} [target={}] Hash to which nascent attributes shall be attached.
     * @returns {Object} The transformed attributes map.
     */
    _generateAttributes: (data, attrTypes={}, target={}) ->
        return target unless data
        return _.reduce do
            data
            (attributes, val, key) ~>
                attributes[key] = @_generateAttribute val, attrTypes[key]
                attributes
            target
    
    
    /**
     * Wraps a single attribute value with the appropriate observable machinery,
     * auto-coercing incoming data to `ModelType` if provided.
     * 
     * @protected
     * @param {*} val Initial value.
     * @param {Class<Model>} [ModelType] Model type to ensure.
     * @returns {ko.observable} The new observable attribute. You should assign
     *  this to the right place on `attributes`, bro.
     */
    _generateAttribute: (val, ModelType) ->
        if _.isArray val
            obs = ko.observableArray val
        else
            if typeof ModelType is not 'function' and _.isPlainObject(val)
                val = @_generateAttributes val, ModelType
            obs = ko.observable val
        obs = obs.typed ModelType if ModelType
        obs
    
    
    
    # }}}
    
    
    toString: ->
        cid       = @__id__
        id        = @peek(@idAttribute or 'id')
        Class     = @constructor
        className = Class.displayName or Class.name
        "#className(cid=#cid, id=#id)"
    
    
    
    
    /* * * *  Class Methods  * * * {{{ */
    
    # Make the Model class-object itself an event emitter, so it can fire global events
    this import EventEmitter::
    
    
    /**
     * @static
     * @returns {Function} Factory function that creates new instances of this Model.
     */
    @getFactory = ->
        ModelType = this
        return (attributes) -> new ModelType attributes
    
    /**
     * Decorates a method when attached to the class prototype so that it
     * becomes a computed property when the class is instantiated.
     * 
     * @static
     * @param {Object} [options] Options to pass to `ko.computed`.
     * @param {Function} method Method to decorate.
     * @returns {Function} Decorated method.
     */
    @computed = (options, method) ->
        [method, options] = [options, {}] if typeof options is 'function'
        method.__computed__ = true
        method.__computed_options__ = {+deferEvaluation} import options
        method
    
    /**
     * Decorates a method when attached to the class prototype so that it
     * becomes an async computed property when the class is instantiated.
     * 
     * @static
     * @param {Function} method Method to decorate.
     * @returns {Function} Decorated method.
     */
    @asyncComputed = (options, method) ->
        [method, options] = [options, {}] if typeof options is 'function'
        method.__async_computed__ = true
        method.__async_computed_options__ = {+deferEvaluation} import options
        method
    
    
    /**
     * Invoked when Model is extended; copies over all class methods to the Subclass (including this).
     * @protected
     * @static
     */
    @extended = (SubClass) ->
        SuperClass = this
        for own k, v in SuperClass
            SubClass[k] = v unless SubClass[k]
            # SubClass[k] = v unless _.contains <[ apply call constructor toString ]>, k
        SubClass.__id__    = generateId()
        SubClass.__super__ = SuperClass::
        SubClass
    
    # }}}


