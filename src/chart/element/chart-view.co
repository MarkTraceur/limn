d3 = require 'd3'
Seq = require 'seq'

{ _, op,
} = limn = require 'limn/client'
{ BaseView,
} = require '../../base'
{ ChartElementData,
} = require './chart-element-data'
{ ChartElement,
} = require './chart-element'


/**
 * @class
 * @extends BaseView
 */
ChartView = exports.ChartView = BaseView.extend do # {{{
    __bind__  : <[  ]>
    typeName  : 'ChartView'
    tagName   : 'section'
    className : 'chart'
    template : require '../../template/chart/chart-view'
    
    events : {}
    
    viewEvents :
        'render' : 'onRender'
    
    xScale : null
    yScale : null
    
    
    constructor: function ChartView (opts)
        BaseView ...
        @chart = this
    
    initialize: (opts) ->
        ChartView.__super__.initialize ...
        @elements = ChartElement.createChildren this, { graph:@model, chart:this }
        @xScale = d3.time.scale().clamp(true)
        @yScale = d3.scale.log()
        /* do something like this to get different types of scales
        switch @model.get('yScale')
            case 'log' then     @yScale = d3.scale.log()
            case 'linear' then  @yScale = d3.scale.linear()
            default then        console.error('The type of scale for the Y dimension is not specified')
        */
    
    /**
     * Changes the x and y scale domains to include the minimum and maximum of the values passed in
     * @param - xValues: one or two dimensional array with values that the X domain should accomodate
     * @param - yValues: one or two dimensional array with values that the Y domain should accomodate
     */
    changeScaleDomain: (xValues, yValues) ->
        @xScale.domain d3.extent d3.merge xValues
        @yScale.domain d3.extent d3.merge yValues
        this
    
    /**
     * Updates the x and y scale domains to include the minimum and maximum of the values passed in
     * @param - xColumn: one dimensional array to accomodate in the X domain
     * @param - yColumn: one dimensional array to accomodate in the Y domain
     */
    updateScaleDomain: (xColumn, yColumn) ->
        xValues = @xScale.domain().concat xColumn
        yValues = @yScale.domain().concat yColumn
        changeScaleDomain xValues, yValues
        this
    
    
    
    ### Rendering {{{
    
    
    layout = {
        h: 0,
        w: 0,
        top:    { x: 0,     y: 0,       h: 30,      w: null },
        bottom: { x: 0,     y: null,    h: 30,      w: null },
        left:   { x: 0,     y: null,    h: null,    w: 60   },
        right:  { x: null,  y: null,    h: null,    w: 60   },
        middle: { x: null,  y: null,    h: null,    w: null }
    }
    
    determineSize: (refEl=@$el) ->
        refEl = $ refEl
        width  = @model.get 'width'
        height = @model.get 'height'
        
        if width is 'auto'
            width = refEl.innerWidth() or 300
        
        if height is 'auto'
            height = refEl.innerHeight() or 320
        
        { width, height }
    
    /**
     * Figures out common components that will be needed to manage any visualization
     * 1. width and height
     */
    build: ->
        ChartView.__super__.build ...
        
        size = @determineSize()
        @$ 'svg' .attr size
        
        # set up and calculate the layout
        @layout.w = size.width
        @layout.h = size.height
        @layout.top.w = @layout.bottom.w = @layout.w
        @layout.middle.w = @layout.w - (@layout.left.w + @layout.right.w)
        @layout.left.h = @layout.right.h = @layout.middle.h = @layout.h - (@layout.top.h + @layout.bottom.h)
        
        @layout.bottom.y = @layout.h - @layout.bottom.h
        @layout.left.y = @layout.right.y = @layout.middle.y = @layout.top.h
        @layout.right.x = @layout.w - @layout.right.w
        @layout.middle.x = @layout.left.w
        @layout.middle.y = layout.top.h
        
        this
    
    onRender: ->
        { width, height } = size = @determineSize()
        @$ 'svg' .attr size
        @xScale.range [0, @layout.middle.w]
        @yScale.range [0, @layout.middle.h]
    
    # }}}

# }}}
