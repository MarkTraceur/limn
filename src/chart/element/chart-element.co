d3 = require 'd3'
Seq = require 'seq'
Backbone = require 'backbone'

{ _, op,
} = limn = require 'limn/client'
{ BaseView,
} = require '../../base'
{ ChartElementData,
} = require './chart-element-data'


/**
 * @class
 * @extends BaseView
 */
ChartElement = exports.ChartElement = BaseView.extend do # {{{
    __bind__     : <[  ]>
    __opt2attr__ : <[ graph chart ]>
    typeName     : 'ChartElement'
    tagName      : 'g'
    className    : 'chart-element'
    
    /**
     * The graph for this element tree.
     * @type Graph
     */
    graph : null
    
    /**
     * The root chart of this element tree.
     * @type ChartView
     */
    chart : null
    
    /**
     * Selection of the element for this view, used by @select() and @selectAll().
     * Defaults to `d3.select(this.el)`.
     * @type d3.selection
     */
    sel : null
    
    elements : null
    
    
    
    
    /**
     * @constructor
     * - Model should be an instance of ChartElementData.
     */
    constructor: function ChartElement (opts)
        BaseView ...
    
    initialize: (opts) ->
        @sel = d3.select @el
        ChartElement.__super__.initialize ...
        ChartElement.propagateEvent 'layout:chart', this
        ChartElement.propagateEvent 'ready:defs', this
        ChartElement.propagateEvent 'changed:data', this
    
    
    
    ### d3 integration {{{
    
    select: (selector) ->
        @sel?.select selector
    
    selectAll: (selector) ->
        @sel?.selectAll selector
    
    
    
    
    # }}}
    ### Rendering {{{
    
    build: ->
        @attachSubviews()
        @isBuilt = true
        this
    
    render: ->
        if @isBuilt
            @update()
        else
            @build()
        @renderSubviews()
        @trigger 'render', this
        this
    
    update: ->
        locals = @toTemplateLocals()
        @trigger 'update', this, locals
        this
    
    /**
     * Overwriting Backbone's BackboneView.make method to use the SVG namespace
     */
    make: (tagName, attributes, content) ->
        el = document.createElementNS 'http://www.w3.org/2000/svg', tagName
        if attributes
            $(el).attr attributes
        if content
            $(el).html content
        el
    
    # }}}
    
    getClassName: ->
        "#{@typeName or @..displayName or @..name}"
    
    toString: ->
        "#{@getClassName()}(model=#{@model})"
    
# }}}



/**
 * Map of known libraries by name.
 * @type Object
 */
KNOWN_CHART_TYPES = exports.KNOWN_CHART_TYPES = {}
_extendChartElement = ChartElement.extend

### Class Methods
ChartElement import do
    
    /**
     * Register a new chart type.
     */
    register : (Subclass) ->
        # console.log "ChartElement.register(#Subclass)"
        unless Subclass?::?.hasOwnProperty('typeName') and typeName = Subclass?::?typeName
            throw new Error "Chart Element types must declare a new, unique typeName on the prototype! (got #{Subclass?::?typeName})"
        if KNOWN_CHART_TYPES[typeName]
            throw new Error "Duplicate Chart Element typeName! (got #typeName)"
        KNOWN_CHART_TYPES[ typeName ] = Subclass
    
    
    /**
     * Look up a `ChartElement` by `typeName`.
     */
    lookup : (name) ->
        name = _.get name, 'elementType' unless _.isString name
        KNOWN_CHART_TYPES[name]
    
    /**
     * Help bubble events down from a reference point
     * @param {string} name is the event name
     * @param {Object} reference is the object that would catch the event and has children that might handle it
     */
    propagateEvent: (name, reference) ->
        reference.on name, reference.bubbleEventDown.bind reference, name
    
    /**
     * Look up a chart type by name, returning a new instance
     * with the given model (and, optionally, view).
     * @returns {ChartElement}
     */
    create : (model, chart, graph, opts) ->
        opts = {+addSubviews, ...opts or {}}
        # opts = {+recursive, +addSubviews, ...opts or {}}
        # _model = model
        # console.log "ChartElement.create(#_model) ->", _model
        model = new ChartElementData model unless model instanceof Backbone.Model
        # console.log "  --> ", model
        return null unless Type = @lookup model
        view = new Type {model, chart, graph}
        # @createChildren view, {chart, graph, ...opts} if opts.recursive
        # view
    
    createChildren: (rootView, opts) ->
        opts = {+recursive, +addSubviews, chart:rootView.chart, graph:rootView.graph, ...opts or {}}
        rootView.model.get 'elements' .map (elModel) ~>
            elView = @create elModel, opts.chart, opts.graph, opts
            rootView.addSubview elView      if opts.addSubviews
            @createChildren elView, opts    if opts.recursive
            elView
    
    
    extend : (proto, statics) ->
        unless proto?.hasOwnProperty('typeName') and typeName = proto.typeName
            throw new Error "Chart Element types must declare a new, unique typeName on the prototype! (got #{proto?.typeName})"
        if KNOWN_CHART_TYPES[typeName]
            throw new Error "Duplicate Chart Element typeName! (got #typeName)"
        
        Subclass = _extendChartElement.call this, proto, statics
        @register Subclass
    


require './vis'
require './meta'

