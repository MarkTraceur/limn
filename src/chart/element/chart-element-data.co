Seq = require 'seq'

{ _, op,
} = limn = require 'limn/client'
{ Cascade,
} = require '../../util'
{ BaseModel, BaseList, ModelCache,
} = require '../../base'
{ DataSource, DataSourceList,
} = require '../../data/datasource-model'



/**
 * @class Model for a ChartElement. See graph/graph-model.co and chart/element/chart-element.co for details.
 * @extends BaseModel
 */
ChartElementData = exports.ChartElementData = BaseModel.extend do # {{{
    __opt2attr__ : <[ graph chart ]>
    NEW_METRIC_LABEL : 'New Metric'
    
    /**
     * Data source for this element.
     * @type DataSource
     */
    source : null
    
    /**
     * Whether this element has loaded the actual data needed to draw the chart.
     * @type Boolean
     */
    dataReady : false
    
    /**
     * Class of the chart element view.
     * @type Class<ChartElement>
     */
    elementType : null
    
    /**
     * View instance rendering this element.
     * @type ChartElement
     */
    view : null
    
    /**
     * Reference to parent element, primarily for option cascading.
     * @type ChartElementData
     */
    parent : null
    
    /**
     * Cascade of objects for options lookup (includes own options).
     * @type Cascade
     * @private
     */
    optionCascade : null
    
    /**
     * Children of this ChartElementData, if any.
     * @type ChartElementDataList
     */
    elements : null
    
    
    
    
    /**
     * Model attribute defaults.
     */
    defaults: ->
        elementType    : null # Typename of the ChartElement which renders this element.
        
        index          : 0
        label          : ''
        disabled       : false
        
        data : 
            source_id  : null
            source_col : null
            type       : 'int'
            timespan   : { start:null, end:null, step:null }
        
        options        : {}
        elements       : []
    
    
    
    
    /**
     * @constructor
     */
    constructor: function ChartElementData (attributes={}, opts)
        @elements = new ChartElementDataList
        @optionCascade = new Cascade attributes.options
        BaseModel.call this, attributes, opts
    
    
    initialize : (attributes, opts) ->
        BaseModel::initialize ...
        # console.log "new #{this}! \#elements=#{@elements?.length}", this, @elements
        @optionCascade.setData @attributes
        @elements.reset @get 'elements'
        @set 'elements', @elements, {+silent}
        @setParent that if opts?.parent
        # @on 'change:source_id',     @load,          this
        # @on 'change:source_col',    @updateId,      this
        # @load()
    
    
    
    ### Accessors {{{
    
    setParent: (parent, opts={}) ->
        [old_parent, @parent] = [@parent, parent]
        @unsetParent opts
        @optionCascade.addLookup parent
        @trigger 'parent', this, parent, old_parent unless opts.silent
        this
    
    unsetParent: (opts={}) ->
        [old_parent, @parent] = [@parent, null]
        @optionCascade.removeLookup old_parent
        @trigger 'unparent', this, old_parent unless opts.silent
        this
    
    
    get: (key) ->
        if _.startsWith key, 'options.'
            @getOption key.slice(8)
        else
            ChartElementData.__super__.get.call this, key
    
    set: (key, value, opts) ->
        # Handle @set(values, opts)
        if _.isObject(key) and key?
            [values, opts] = [key, value]
        else
            values = { "#key": value }
        values = @parse values
        
        setter = ChartElementData.__super__.set
        
        # Merge options in, firing granulated change events
        if values.options
            # Remove from values to prevent the super call to `set()` from
            # replacing the object wholesale.
            options = delete values.options
            
            # ...Unless we don't have one yet.
            if not @attributes.options
                setter.call this, {options}, {+silent}
            
            # Now delegate `setOption()` to do the nested merging.
            @setOption options, opts
        
        # Deal with everything else
        setter.call this, values, opts
    
    
    
    # }}}
    ### Chart Option Accessors {{{
    
    hasOption: (key) ->
        @getOption(key) is void
    
    getOption: (key, def) ->
        @optionCascade.get key, def
    
    setOption: (key, value, opts={}) ->
        if _.isObject(key) and key?
            [values, opts] = [key, value or {}]
        else
            values = { "#key": value }
        
        # _.dump values, "#this.setOption"
        options = @get('options')
        changed = false
        for key, value in values
            continue if _.contains @IGNORE_OPTIONS, key
            changed = true
            _.setNested options, key, value, {+ensure}
            @trigger "change:options.#key", this, value, key, opts unless opts.silent
        
        if changed and not opts.silent
            @trigger "change:options",  this, options, 'options', opts
            @trigger "change",          this, options, 'options', opts
        this
    
    unsetOption: (key, opts={}) ->
        unless @optionCascade.unset(key) is void or opts.silent
            options = @get 'options'
            @trigger "change:options.#key", this, void, key, opts
            @trigger "change:options",      this, options, 'options', opts
            @trigger "change",              this, options, 'options', opts
        this
    
    inheritOption: (key, opts={}) ->
        old = @getOption(key)
        @optionCascade.inherit(key)
        unless @getOption(key) is old or opts.silent
            options = @get 'options'
            @trigger "change:options.#key", this, void, key, opts
            @trigger "change:options",      this, options, 'options', opts
            @trigger "change:options",      this, options, 'options', opts
        this
    
    getOptions: (opts={}) ->
        opts = {+keepDefaults, +keepUnchanged} import opts
        options = @optionCascade.collapse()
        for k, v in options
            delete options[k] if v is void or
                (not opts.keepDefaults  and @isDefaultOption k) or
                (not opts.keepUnchanged and not @isChangedOption k)
        options
    
    /**
     * @returns {Boolean} Whether the value for option `k` is inherited or not.
     */
    isOwnOption: (k) ->
        @optionCascade.isOwnValue k
    
    /**
     * @returns {Boolean} Whether the value for option `k` is the graph default or not.
     */
    isDefaultOption: (k) ->
        # @chartType.isDefault k, @getOption k
        false
    
    /**
     * Whether the value for option `k` differs from that of its parent graphs.
     * @returns {Boolean}
     */
    isChangedOption: (k) ->
        @optionCascade.isModifiedValue k
        and not @isDefaultOption k
    
    
    
    # }}}
    ### Loading {{{
    
    load: (opts={}) ->
        source_id = @get 'data.source_id'
        @resetReady() if opts.force or @source?.id is not source_id
        return this if @loading or @ready
        
        unless source_id or @elements.length
            return @triggerReady()
        
        # console.log "#this.load()..."
        @wait()
        @loading = true
        @trigger 'load', this
        
        # perform lookup
        Seq()
            .seq_ (next) ~>
                if source_id and @get('data.source_col') >= 0
                    DataSource.lookup source_id, next
                else
                    next.ok()
            .seq_ (next, source) ~>
                @source = that if source
                next.ok @elements.models
            .flatten()
            .parEach_ (next, child) ~>
                child.once 'ready', next.ok .load()
            .seq ~>
                # console.log "#{this}.load() complete!"
                @loading = false
                @unwait() # terminates the `load` wait
                @triggerReady()
        this
    
    
    loadData: (opts={}) ->
        @resetReady 'dataReady', 'data-ready' if opts.force
        return this if @loading or @dataReady
        
        unless @source or @elements.length
            return @triggerReady 'dataReady', 'data-ready'
        
        # console.log "#this.loadData()..."
        @wait()
        @loading = true
        @trigger 'load-data', this
        Seq()
            .seq_ (next) ~>
                if not @source or @source.dataReady
                    next.ok()
                else
                    @source.once 'load-data-success', next.ok .loadData()
            .seq_ (next) ~>
                next.ok @elements.models
            .flatten()
            .parEach_ (next, child) ~>
                # Call child.loadData() even without child.source, as we must recurse
                # -- the element could have children of its own.
                child.once 'data-ready', next.ok .loadData()
            .seq ~>
                # console.log "#{this}.loadData() complete!"
                @loading = false
                @unwait() # terminates the `load` wait
                @triggerReady 'dataReady', 'data-ready'
        this
    
    
    # }}}
    ### Data {{{
    
    getDateColumn: ->
        @source?.getDateColumn()
    
    getData: ->
        @source?.getColumn @get 'data.source_col'
    
    getLabel: ->
        @get('label') or @getPlaceholderLabel()
    
    getPlaceholderLabel: ->
        col  = @get 'data.source_col'
        name = "#{@source.get 'shortName'}, #{@source.getColumnName col}" if @source and col >= 0
        name or @NEW_METRIC_LABEL
    
    getSourceColumnName: ->
        col = @get 'data.source_col'
        @source.getColumnName col if @source and col > 0
    
    getColor: ->
        @get('color') or ProjectColors.lookup(@get('label')) or 'black'
    
    
    # }}}
    
    
    toJSON: (opts={}) ->
        opts = {+keepDefaults, +keepUnchanged} import opts
        json = _.merge {}, @attributes, { options:@getOptions(opts) }
        # { data: ...json }
    
    
    getClassName: ->
        className = ChartElementData.__super__.getClassName ...
        "#className<#{@get 'elementType'}>"
    
    toString: (dumpChildren=false) ->
        {elementType, data} = @attributes
        dataset = if data then "#{data.source_id}[#{data.source_col}]" else null
        if dumpChildren
            elements = "elements=[ #{@elements.invoke('toString', true).join ', '} ]"
        else
            elements = "\#elements=#{@elements?.length}"
        "#{@getClassName()}(cid=#{@cid}, data=#dataset, #elements)"
    
# }}}


/**
 * @class
 * @extends BaseList
 */
ChartElementDataList = exports.ChartElementDataList = BaseList.extend do # {{{
    model : ChartElementData
    
    constructor: function ChartElementDataList then BaseList ...
    initialize : -> BaseList::initialize ...
# }}}
