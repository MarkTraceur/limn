_       = require 'underscore'
op      = require 'operator'
ko      = require 'knockout'
Seq     = require 'seq'

{ ReadyEmitter,
} = require 'emitters'

{ Model, StoredModel, ModelCache,
} = require '../base'
{ ParserMixin,
} = require '../util/parser-mixin'




class exports.Column extends Model
    ParserMixin.mix this
    
    (attributes, @source) -> super ...
    
    defaults: ->
        id    : null
        label : ''
        type  : 'int'
        index : -1
    
    /**
     * Convert the string representation of a value from this Column to
     * its real type.
     * 
     * @param {String} value A serialized value.
     * @returns {*} The value parsed into the appropriate type.
     */
    parse: (value) ->
        @parseValue value, @get 'type'


class exports.DataSource extends StoredModel
    resource : 'datasources'
    getId    : -> @get 'id'
    
    defaults : ->
        id            : null
        url           : ''
        format        : 'json'
        
        name          : ''
        shortName     : ''
        title         : ''
        subtitle      : ''
        desc          : ''
        notes         : ''
        
        timespan      : { start:null, end:null, step:'1mo' }
        
        /**
         * @type Column[]
         */
        columns       : []
    
    attributeTypes :
        columns : Column
    
    /**
     * The reified dataset associated with this DataSource.
     * @type ko.computed<DataSet>
     */
    data : null
    
    
    /**
     * @constructor
     */
    (attributes={}) ->
        attributes = @canonicalize attributes
        super attributes
    
    
    /**
     * Enforces backwards compatibility at runtime by converting a DataSource from
     * one of many of the historical "formats" we've used to whatever the modern
     * format looks like.
     * 
     * @param {Object} data Raw DataSource attributes to canonicalize.
     * @returns {Object} Converted raw data.
     */
    canonicalize: (data) ->
        data
    
    
    _fetch : ->
        @fetching = $.Deferred()
        @loading = $.Deferred()
        Seq()
            .seq_ (next) ~>
                @fetching.done (attributes) ~> next.ok attributes
                @keepUniquePromise 'fetching', @fetchEasy, @fetching
            
            .seq_ (next, attributes) ~>
                @setAttributes attributes
                @loading.done (data) ~> next.ok data
                @keepUniquePromise 'loading', @loadCSV, @loading
            
            .seq (data) ~>
                @setData data
        
        this
    
    
    /**
     * FIXME: hack because normal fetch isn't working
     * Fetches the datasource metadata
     * @returns {jQuery.Deferred} a promise to fetch the metadata
     */
    fetchEasy: -> $.get @url()
    
    /**
     * Called after fetching, sets this instance's attributes
     * @param {string} attributes the properties of the datasource fetched from the server
     */
    setAttributes: (attributes) ->
        # TODO: parse attributes: v = yaml.load attributes
    
    /**
     * Loads the csv this datasource points to
     * @returns {jQuery.Deferred} a promise to load the csv
     */
    loadCSV: ->
        p = $.Deferred()
        p.resolve("hello CSV world, #{@id()} is here")
        p
    
    /**
     * Called after loading, sets the column data
     * @param {string} data the csv data loaded
     */
    setData: (data) ->
        # TODO: parse data
        # switch @format()
        # case 'json' then @data = new TimeSeriesData data
        # case 'csv'  then @data = new CSVData data
    
    /**
     * Shared among all instances of DataSource to prevent double-promises
     */
    __cache__: {}
    __cacheKey__: (type, id) -> "#type-#id"
    
    /**
     * Uses the __cache__ to make sure only one promise of the `type` passed in is made at a time
     * @param {string} type can be 'fetching', 'loading', or any type of promise that should be unique accross all DataSource with the same id
     * @param {function} task is a function that returns a promise when called.  NOTE: only the task passed in by the first concurrent call is used
     * @param {jQuery.Deferred} keptPromise is the promise to synchronize with the unique promise
     */
    keepUniquePromise: (type, task, keptPromise) ->
        key = @__cacheKey__ type, @id()
        
        unless key in @__cache__
            promise = task.call this
            promise.always ~> delete @__cache__[key]
            @__cache__[key] = promise
        
        @__cache__[key]
            .done (args) ~> keptPromise.resolve(args)
            .fail (args) ~> keptPromise.reject(args)
    
    /**
     * @param {string} data json from the server
     */
    initialize: (yaml) ->
        @data = yaml # TODO: obviously process this data
    
    
    
    


### DataSource Cache

# ReadyEmitter.decorate DataSource
for k of <[ __ready_event__ ready emit trigger on off addListener removeListener removeAllListeners once listeners ]>
    DataSource[k] = ReadyEmitter::[k]

ALL_SOURCES = {}
DataSourceCache = exports.DataSourceCache = new ModelCache DataSource, {-ready, cache:ALL_SOURCES}

# Fetch all DataSources
DataSource.fetchAll = ->
    limn = require '../index'
    $.getJSON limn.mount('datasources/all'), (models) ->
        _.each models, (data) ->
            DataSourceCache.register new DataSource data
        
        # Trigger event when the DataSource TOC is ready
        DataSourceCache.ready()
        DataSource.ready()
        # DataSource.trigger 'all-data-ready', ALL_SOURCES

DataSource.getAllSources = ->
    _.map ALL_SOURCES, op.I



